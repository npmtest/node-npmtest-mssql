{"/home/travis/build/npmtest/node-npmtest-mssql/test.js":"/* istanbul instrument in package npmtest_mssql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mssql/lib.npmtest_mssql.js":"/* istanbul instrument in package npmtest_mssql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_mssql = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_mssql = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-mssql/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-mssql && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_mssql */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_mssql\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_mssql.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_mssql.rollup.js'] =\n            local.assetsDict['/assets.npmtest_mssql.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_mssql.__dirname + '/lib.npmtest_mssql.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/index.js":"module.exports = require('./lib/tedious.js')\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/tedious.js":"'use strict'\n\nconst tds = require('tedious')\nconst debug = require('debug')('mssql:tedious')\n\nconst base = require('./base')\nconst TYPES = require('./datatypes').TYPES\nconst declare = require('./datatypes').declare\nconst cast = require('./datatypes').cast\nconst DECLARATIONS = require('./datatypes').DECLARATIONS\nconst UDT = require('./udt').PARSERS\nconst Table = require('./table')\n\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nconst getTediousType = function (type) {\n  switch (type) {\n    case TYPES.VarChar: return tds.TYPES.VarChar\n    case TYPES.NVarChar: return tds.TYPES.NVarChar\n    case TYPES.Text: return tds.TYPES.Text\n    case TYPES.Int: return tds.TYPES.Int\n    case TYPES.BigInt: return tds.TYPES.BigInt\n    case TYPES.TinyInt: return tds.TYPES.TinyInt\n    case TYPES.SmallInt: return tds.TYPES.SmallInt\n    case TYPES.Bit: return tds.TYPES.Bit\n    case TYPES.Float: return tds.TYPES.Float\n    case TYPES.Decimal: return tds.TYPES.Decimal\n    case TYPES.Numeric: return tds.TYPES.Numeric\n    case TYPES.Real: return tds.TYPES.Real\n    case TYPES.Money: return tds.TYPES.Money\n    case TYPES.SmallMoney: return tds.TYPES.SmallMoney\n    case TYPES.Time: return tds.TYPES.TimeN\n    case TYPES.Date: return tds.TYPES.DateN\n    case TYPES.DateTime: return tds.TYPES.DateTime\n    case TYPES.DateTime2: return tds.TYPES.DateTime2N\n    case TYPES.DateTimeOffset: return tds.TYPES.DateTimeOffsetN\n    case TYPES.SmallDateTime: return tds.TYPES.SmallDateTime\n    case TYPES.UniqueIdentifier: return tds.TYPES.UniqueIdentifierN\n    case TYPES.Xml: return tds.TYPES.NVarChar\n    case TYPES.Char: return tds.TYPES.Char\n    case TYPES.NChar: return tds.TYPES.NChar\n    case TYPES.NText: return tds.TYPES.NVarChar\n    case TYPES.Image: return tds.TYPES.Image\n    case TYPES.Binary: return tds.TYPES.Binary\n    case TYPES.VarBinary: return tds.TYPES.VarBinary\n    case TYPES.UDT: case TYPES.Geography: case TYPES.Geometry: return tds.TYPES.UDT\n    case TYPES.TVP: return tds.TYPES.TVP\n    case TYPES.Variant: return tds.TYPES.Variant\n    default: return type\n  }\n}\n\nconst getMssqlType = function (type, length) {\n  switch (type) {\n    case tds.TYPES.Char: return TYPES.Char\n    case tds.TYPES.NChar: return TYPES.NChar\n    case tds.TYPES.VarChar: return TYPES.VarChar\n    case tds.TYPES.NVarChar: return TYPES.NVarChar\n    case tds.TYPES.Text: return TYPES.Text\n    case tds.TYPES.NText: return TYPES.NText\n    case tds.TYPES.Int: return TYPES.Int\n    case tds.TYPES.IntN:\n      if (length === 8) return TYPES.BigInt\n      if (length === 4) return TYPES.Int\n      if (length === 2) return TYPES.SmallInt\n      return TYPES.TinyInt\n    case tds.TYPES.BigInt: return TYPES.BigInt\n    case tds.TYPES.TinyInt: return TYPES.TinyInt\n    case tds.TYPES.SmallInt: return TYPES.SmallInt\n    case tds.TYPES.Bit: case tds.TYPES.BitN: return TYPES.Bit\n    case tds.TYPES.Float: return TYPES.Float\n    case tds.TYPES.FloatN:\n      if (length === 8) return TYPES.Float\n      return TYPES.Real\n    case tds.TYPES.Real: return TYPES.Real\n    case tds.TYPES.Money: return TYPES.Money\n    case tds.TYPES.MoneyN:\n      if (length === 8) return TYPES.Money\n      return TYPES.SmallMoney\n    case tds.TYPES.SmallMoney: return TYPES.SmallMoney\n    case tds.TYPES.Numeric: case tds.TYPES.NumericN: return TYPES.Numeric\n    case tds.TYPES.Decimal: case tds.TYPES.DecimalN: return TYPES.Decimal\n    case tds.TYPES.DateTime: return TYPES.DateTime\n    case tds.TYPES.DateTimeN:\n      if (length === 8) return TYPES.DateTime\n      return TYPES.SmallDateTime\n    case tds.TYPES.TimeN: return TYPES.Time\n    case tds.TYPES.DateN: return TYPES.Date\n    case tds.TYPES.DateTime2N: return TYPES.DateTime2\n    case tds.TYPES.DateTimeOffsetN: return TYPES.DateTimeOffset\n    case tds.TYPES.SmallDateTime: return TYPES.SmallDateTime\n    case tds.TYPES.UniqueIdentifierN: return TYPES.UniqueIdentifier\n    case tds.TYPES.Image: return TYPES.Image\n    case tds.TYPES.Binary: return TYPES.Binary\n    case tds.TYPES.VarBinary: return TYPES.VarBinary\n    case tds.TYPES.Xml: return TYPES.Xml\n    case tds.TYPES.UDT: return TYPES.UDT\n    case tds.TYPES.TVP: return TYPES.TVP\n    case tds.TYPES.Variant: return TYPES.Variant\n  }\n}\n\nconst createColumns = function (metadata) {\n  let out = {}\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    let column = metadata[index]\n    out[column.colName] = {\n      index,\n      name: column.colName,\n      length: column.dataLength,\n      type: getMssqlType(column.type, column.dataLength),\n      scale: column.scale,\n      precision: column.precision,\n      nullable: !!(column.flags & 0x01),\n      caseSensitive: !!(column.flags & 0x02),\n      identity: !!(column.flags & 0x10),\n      readOnly: !(column.flags & 0x0C)\n    }\n\n    if (column.udtInfo) {\n      out[column.colName].udt = {\n        name: column.udtInfo.typeName,\n        database: column.udtInfo.dbname,\n        schema: column.udtInfo.owningSchema,\n        assembly: column.udtInfo.assemblyName\n      }\n\n      if (DECLARATIONS[column.udtInfo.typeName]) {\n        out[column.colName].type = DECLARATIONS[column.udtInfo.typeName]\n      }\n    }\n  }\n\n  return out\n}\n\nconst valueCorrection = function (value, metadata) {\n  if ((metadata.type === tds.TYPES.UDT) && (value != null)) {\n    if (UDT[metadata.udtInfo.typeName]) {\n      return UDT[metadata.udtInfo.typeName](value)\n    } else {\n      return value\n    }\n  } else {\n    return value\n  }\n}\n\nconst parameterCorrection = function (value) {\n  if (value instanceof Table) {\n    const tvp = {\n      name: value.name,\n      schema: value.schema,\n      columns: [],\n      rows: value.rows\n    }\n\n    for (let col of value.columns) {\n      tvp.columns.push({\n        name: col.name,\n        type: getTediousType(col.type),\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      })\n    }\n\n    return tvp\n  } else {\n    return value\n  }\n}\n\nclass ConnectionPool extends base.ConnectionPool {\n  _poolCreate () {\n    return new base.Promise((resolve, reject) => {\n      const cfg = {\n        userName: this.config.user,\n        password: this.config.password,\n        server: this.config.server,\n        options: Object.assign({}, this.config.options),\n        domain: this.config.domain\n      }\n\n      cfg.options.database = this.config.database\n      cfg.options.port = this.config.port\n      cfg.options.connectTimeout = this.config.connectionTimeout || this.config.timeout || 15000\n      cfg.options.requestTimeout = this.config.requestTimeout != null ? this.config.requestTimeout : 15000\n      cfg.options.tdsVersion = cfg.options.tdsVersion || '7_4'\n      cfg.options.rowCollectionOnDone = false\n      cfg.options.rowCollectionOnRequestCompletion = false\n      cfg.options.useColumnNames = false\n      cfg.options.appName = cfg.options.appName || 'node-mssql'\n\n      // tedious always connect via tcp when port is specified\n      if (cfg.options.instanceName) delete cfg.options.port\n\n      if (isNaN(cfg.options.requestTimeout)) cfg.options.requestTimeout = 15000\n      if (cfg.options.requestTimeout === Infinity) cfg.options.requestTimeout = 0\n      if (cfg.options.requestTimeout < 0) cfg.options.requestTimeout = 0\n\n      if (this.config.debug) {\n        cfg.options.debug = {\n          packet: true,\n          token: true,\n          data: true,\n          payload: true\n        }\n      }\n\n      const tedious = new tds.Connection(cfg)\n\n      tedious.once('connect', err => {\n        if (err) {\n          err = new base.ConnectionError(err)\n          return reject(err)\n        }\n\n        resolve(tedious)\n      })\n\n      tedious.on('error', err => {\n        if (err.code === 'ESOCKET') {\n          tedious.hasError = true\n          return\n        }\n\n        this.emit('error', err)\n      })\n\n      if (this.config.debug) {\n        tedious.on('debug', msg => this._debug(msg))\n      }\n    })\n  }\n\n  _poolValidate (tedious) {\n    return new base.Promise((resolve, reject) => {\n      resolve(!tedious.closed && !tedious.hasError)\n    })\n  }\n\n  _poolDestroy (tedious) {\n    return new base.Promise((resolve, reject) => {\n      tedious.once('end', () => {\n        resolve()\n      })\n\n      tedious.close()\n    })\n  }\n}\n\nclass Transaction extends base.Transaction {\n  constructor (parent) {\n    super(parent)\n\n    this._abort = () => {\n      if (!this._rollbackRequested) {\n        // transaction interrupted because of XACT_ABORT\n\n        const pc = this._acquiredConnection\n\n        // defer releasing so connection can switch from SentClientRequest to LoggedIn state\n        setImmediate(this.parent.release.bind(this.parent), pc)\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort)\n        this._acquiredConnection = null\n        this._aborted = true\n\n        this.emit('rollback', true)\n      }\n    }\n  }\n\n  _begin (isolationLevel, callback) {\n    super._begin(isolationLevel, err => {\n      if (err) return callback(err)\n\n      debug('tran: begin')\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        this._acquiredConnection = connection\n        this._acquiredConnection.on('rollbackTransaction', this._abort)\n\n        connection.beginTransaction(err => {\n          if (err) err = new base.TransactionError(err)\n\n          debug('tran: begin ok')\n\n          callback(err)\n        }, this.name, this.isolationLevel)\n      })\n    })\n  }\n\n  _commit (callback) {\n    super._commit(err => {\n      if (err) return callback(err)\n\n      debug('tran: commit')\n\n      this._acquiredConnection.commitTransaction(err => {\n        if (err) err = new base.TransactionError(err)\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort)\n        this.parent.release(this._acquiredConnection)\n        this._acquiredConnection = null\n\n        if (!err) debug('tran: commit ok')\n\n        callback(err)\n      })\n    })\n  }\n\n  _rollback (callback) {\n    super._rollback(err => {\n      if (err) return callback(err)\n\n      debug('tran: rollback')\n\n      this._acquiredConnection.rollbackTransaction(err => {\n        if (err) err = new base.TransactionError(err)\n\n        this._acquiredConnection.removeListener('rollbackTransaction', this._abort)\n        this.parent.release(this._acquiredConnection)\n        this._acquiredConnection = null\n\n        if (!err) debug('tran: rollback ok')\n\n        callback(err)\n      })\n    })\n  }\n}\n\nclass Request extends base.Request {\n  /*\n  Execute specified sql batch.\n  */\n\n  _batch (batch, callback) {\n    this._isBatch = true\n    this._query(batch, callback)\n  }\n\n  /*\n  Bulk load.\n  */\n\n  _bulk (table, callback) {\n    super._bulk(table, err => {\n      if (err) return callback(err)\n\n      table._makeBulk()\n\n      if (!table.name) {\n        return callback(new base.RequestError('Table name must be specified for bulk insert.', 'ENAME'))\n      }\n\n      if (table.name.charAt(0) === '@') {\n        return callback(new base.RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\n      }\n\n      const errors = []\n      const errorHandlers = {}\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new base.RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        if (this.canceled) {\n          debug('req: canceled')\n          this.parent.release(connection)\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('req: cancel')\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const done = (err, rowCount) => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new base.RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          this._cancel = null\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (this.stream) {\n              callback(null, rowCount)\n            } else {\n              callback(error, rowCount)\n            }\n          }\n        }\n\n        const bulk = connection.newBulkLoad(table.path, done)\n\n        for (let col of table.columns) {\n          bulk.addColumn(col.name, getTediousType(col.type), {nullable: col.nullable, length: col.length, scale: col.scale, precision: col.precision})\n        }\n\n        for (let row of table.rows) {\n          bulk.addRow(row)\n        }\n\n        if (table.create) {\n          const objectid = table.temporary ? `tempdb..[${table.name}]` : table.path\n          const req = new tds.Request(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, err => {\n            if (err) return done(err)\n\n            connection.execBulkLoad(bulk)\n          })\n\n          connection.execSqlBatch(req)\n        } else {\n          connection.execBulkLoad(bulk)\n        }\n      })\n    })\n  }\n\n  /*\n  Execute specified sql command.\n  */\n\n  _query (command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err)\n\n      debug('req: query:', command)\n\n      const recordsets = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let batchLastRow = null\n      let batchHasOutput = false\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new base.RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      const handleInfo = msg => {\n        this.emit('info', {\n          message: msg.message,\n          number: msg.number,\n          state: msg.state,\n          class: msg.class,\n          lineNumber: msg.lineNumber,\n          serverName: msg.serverName,\n          procName: msg.procName\n        })\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        let row\n\n        if (this.canceled) {\n          debug('req: canceling')\n          this.parent.release(connection)\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('req: cancel')\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('infoMessage', errorHandlers.infoMessage = handleInfo)\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const req = new tds.Request(command, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new base.RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          // process batch outputs\n          if (batchHasOutput) {\n            if (!this.stream) batchLastRow = recordsets.pop()[0]\n\n            for (let name in batchLastRow) {\n              let value = batchLastRow[name]\n              if (name !== '___return___') {\n                output[name] = value === tds.TYPES.Null ? null : value\n              }\n            }\n          }\n\n          this._cancel = null\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('req: query fail', error)\n            } else {\n              debug('req: query ok')\n            }\n\n            if (this.stream) {\n              callback(null, null, output, rowsAffected)\n            } else {\n              callback(error, recordsets, output, rowsAffected)\n            }\n          }\n        })\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata)\n\n          isChunkedRecordset = false\n          if (metadata.length === 1 && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // don't stream recordset with output values in batches\n              if (!columns.___return___) {\n                this.emit('recordset', columns)\n              }\n            } else {\n              this.emit('recordset', columns)\n            }\n          }\n        }\n        )\n\n        const doneHandler = (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount)\n          // this function is called even when select only set variables so we should skip adding a new recordset\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && this.connection.config.parseJSON === true) {\n              try {\n                row = JSON.parse(chunksBuffer.join(''))\n              } catch (ex) {\n                row = null\n                const ex2 = new base.RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value () { return Table.fromRecordset(this) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        }\n\n        req.on('doneInProc', doneHandler) // doneInProc handlers are used in both queries and batches\n        req.on('done', doneHandler) // done handlers are used in batches\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value === tds.TYPES.Null ? null : value\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          row = {}\n          for (let col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            let exi = row[col.metadata.colName]\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value)\n              } else {\n                row[col.metadata.colName] = [exi, col.value]\n              }\n            } else {\n              row[col.metadata.colName] = col.value\n            }\n          }\n\n          if (this.stream) {\n            if (this._isBatch) {\n              // dont stream recordset with output values in batches\n              if (row.___return___) {\n                batchLastRow = row\n              } else {\n                this.emit('row', row)\n              }\n            } else {\n              this.emit('row', row)\n            }\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        if (this._isBatch) {\n          if (Object.keys(this.parameters).length) {\n            for (let name in this.parameters) {\n              let param = this.parameters[name]\n              let value = getTediousType(param.type).validate(param.value)\n\n              if (value instanceof TypeError) {\n                value = new base.RequestError(`Validation failed for parameter '${name}'. ${value.message}`, 'EPARAM')\n\n                this.parent.release(connection)\n                return callback(value)\n              }\n\n              param.value = value\n            }\n\n            const declarations = []\n            for (let name in this.parameters) {\n              let param = this.parameters[name]\n              declarations.push(`@${name} ${declare(param.type, param)}`)\n            }\n\n            const assigns = []\n            for (let name in this.parameters) {\n              let param = this.parameters[name]\n              assigns.push(`@${name} = ${cast(param.value, param.type, param)}`)\n            }\n\n            const selects = []\n            for (let name in this.parameters) {\n              let param = this.parameters[name]\n              if (param.io === 2) {\n                selects.push(`@${name} as [${name}]`)\n              }\n            }\n\n            batchHasOutput = selects.length > 0\n\n            req.sqlTextOrProcedure = `declare ${declarations.join(', ')};select ${assigns.join(', ')};${req.sqlTextOrProcedure};${batchHasOutput ? (`select 1 as [___return___], ${selects.join(', ')}`) : ''}`\n          }\n        } else {\n          for (let name in this.parameters) {\n            let param = this.parameters[name]\n            if (param.io === 1) {\n              req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {length: param.length, scale: param.scale, precision: param.precision})\n            } else {\n              req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {length: param.length, scale: param.scale, precision: param.precision})\n            }\n          }\n        }\n\n        connection[this._isBatch ? 'execSqlBatch' : 'execSql'](req)\n      })\n    })\n  }\n\n  /*\n  Execute stored procedure with specified parameters.\n  */\n\n  _execute (procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err)\n\n      debug('req: execute:', procedure)\n\n      const recordsets = []\n      const errors = []\n      const errorHandlers = {}\n      const output = {}\n      const rowsAffected = []\n\n      let columns = {}\n      let recordset = []\n      let returnValue = 0\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n      let hasReturned = false\n\n      const handleError = (doReturn, connection, info) => {\n        let err = new Error(info.message)\n        err.info = info\n        err = new base.RequestError(err, 'EREQUEST')\n\n        if (this.stream) {\n          this.emit('error', err)\n        } else {\n          if (doReturn && !hasReturned) {\n            if (connection) {\n              for (let event in errorHandlers) {\n                connection.removeListener(event, errorHandlers[event])\n              }\n\n              this.parent.release(connection)\n            }\n\n            hasReturned = true\n            callback(err)\n          }\n        }\n\n        // we must collect errors even in stream mode\n        errors.push(err)\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        let row\n\n        if (this.canceled) {\n          debug('req: canceling')\n          this.parent.release(connection)\n          return callback(new base.RequestError('Canceled.', 'ECANCEL'))\n        }\n\n        this._cancel = () => {\n          debug('req: cancel')\n          connection.cancel()\n        }\n\n        // attach handler to handle multiple error messages\n        connection.on('errorMessage', errorHandlers.errorMessage = handleError.bind(null, false, connection))\n        connection.on('error', errorHandlers.error = handleError.bind(null, true, connection))\n\n        const req = new tds.Request(procedure, err => {\n          // to make sure we handle no-sql errors as well\n          if (err && (!errors.length || (errors.length && err.message !== errors[errors.length - 1].message))) {\n            err = new base.RequestError(err, 'EREQUEST')\n            if (this.stream) this.emit('error', err)\n            errors.push(err)\n          }\n\n          this._cancel = null\n\n          let error\n          if (errors.length && !this.stream) {\n            error = errors.pop()\n            error.precedingErrors = errors\n          }\n\n          if (!hasReturned) {\n            for (let event in errorHandlers) {\n              connection.removeListener(event, errorHandlers[event])\n            }\n\n            this.parent.release(connection)\n            hasReturned = true\n\n            if (error) {\n              debug('req: execute fail', error)\n            } else {\n              debug('req: execute ok')\n            }\n\n            if (this.stream) {\n              callback(null, null, output, returnValue, rowsAffected)\n            } else {\n              callback(error, recordsets, output, returnValue, rowsAffected)\n            }\n          }\n        })\n\n        req.on('columnMetadata', metadata => {\n          columns = createColumns(metadata)\n\n          isChunkedRecordset = false\n          if ((metadata.length === 1) && (metadata[0].colName === JSON_COLUMN_ID || metadata[0].colName === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) this.emit('recordset', columns)\n        })\n\n        req.on('row', columns => {\n          if (!recordset) recordset = []\n\n          if (isChunkedRecordset) {\n            return chunksBuffer.push(columns[0].value)\n          }\n\n          row = {}\n          for (let col of columns) {\n            col.value = valueCorrection(col.value, col.metadata)\n\n            let exi = row[col.metadata.colName]\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(col.value)\n              } else {\n                row[col.metadata.colName] = [exi, col.value]\n              }\n            } else {\n              row[col.metadata.colName] = col.value\n            }\n          }\n\n          if (this.stream) {\n            this.emit('row', row)\n          } else {\n            recordset.push(row)\n          }\n        })\n\n        req.on('doneInProc', (rowCount, more) => {\n          if (rowCount != null) rowsAffected.push(rowCount)\n\n          // filter empty recordsets when NOCOUNT is OFF\n          if (Object.keys(columns).length === 0) return\n\n          if (isChunkedRecordset) {\n            if (columns[JSON_COLUMN_ID] && connection.config.parseJSON === true) {\n              try {\n                row = JSON.parse(chunksBuffer.join(''))\n              } catch (ex) {\n                row = null\n                const ex2 = new base.RequestError(new Error(`Failed to parse incoming JSON. ${ex.message}`), 'EJSON')\n\n                if (this.stream) this.emit('error', ex2)\n\n                // we must collect errors even in stream mode\n                errors.push(ex2)\n              }\n            } else {\n              row = {}\n              row[Object.keys(columns)[0]] = chunksBuffer.join('')\n            }\n\n            chunksBuffer = null\n\n            if (this.stream) {\n              this.emit('row', row)\n            } else {\n              recordset.push(row)\n            }\n          }\n\n          if (!this.stream) {\n            // all rows of current recordset loaded\n            Object.defineProperty(recordset, 'columns', {\n              enumerable: false,\n              configurable: true,\n              value: columns\n            })\n\n            Object.defineProperty(recordset, 'toTable', {\n              enumerable: false,\n              configurable: true,\n              value () { return Table.fromRecordset(this) }\n            })\n\n            recordsets.push(recordset)\n          }\n\n          recordset = []\n          columns = {}\n        })\n\n        req.on('doneProc', (rowCount, more, returnStatus) => {\n          returnValue = returnStatus\n        })\n\n        req.on('returnValue', (parameterName, value, metadata) => {\n          output[parameterName] = value === tds.TYPES.Null ? null : value\n        })\n\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          if (param.io === 1) {\n            req.addParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {length: param.length, scale: param.scale, precision: param.precision})\n          } else {\n            req.addOutputParameter(param.name, getTediousType(param.type), parameterCorrection(param.value), {length: param.length, scale: param.scale, precision: param.precision})\n          }\n        }\n\n        connection.callProcedure(req)\n      })\n    })\n  }\n}\n\nmodule.exports = Object.assign({\n  ConnectionPool,\n  Transaction,\n  Request,\n  PreparedStatement: base.PreparedStatement\n}, base.exports)\n\nObject.defineProperty(module.exports, 'Promise', {\n  enumerable: true,\n  get: () => {\n    return base.Promise\n  },\n  set: (value) => {\n    base.Promise = value\n  }\n})\n\nbase.driver.name = 'tedious'\nbase.driver.ConnectionPool = ConnectionPool\nbase.driver.Transaction = Transaction\nbase.driver.Request = Request\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/base.js":"'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst debug = require('debug')('mssql')\nconst gp = require('generic-pool')\n\nconst TYPES = require('./datatypes').TYPES\nconst declare = require('./datatypes').declare\nconst ISOLATION_LEVEL = require('./isolationlevel')\nconst Table = require('./table')\nconst ConnectionString = require('./connectionstring')\n\nlet globalConnection = null\nlet PromiseLibrary = Promise\nconst globalConnectionHandlers = {}\nconst map = []\nconst driver = {}\n\n/**\n * Register you own type map.\n *\n * @path module.exports.map\n * @param {*} jstype JS data type.\n * @param {*} sqltype SQL data type.\n */\n\nmap.register = function (jstype, sqltype) {\n  for (let index = 0; index < this.length; index++) {\n    let item = this[index]\n    if (item.js === jstype) {\n      this.splice(index, 1)\n      break\n    }\n  }\n\n  this.push({\n    js: jstype,\n    sql: sqltype\n  })\n\n  return null\n}\n\nmap.register(String, TYPES.NVarChar)\nmap.register(Number, TYPES.Int)\nmap.register(Boolean, TYPES.Bit)\nmap.register(Date, TYPES.DateTime)\nmap.register(Buffer, TYPES.VarBinary)\nmap.register(Table, TYPES.TVP)\n\n/**\n * @ignore\n */\n\nlet getTypeByValue = function (value) {\n  if ((value === null) || (value === undefined)) { return TYPES.NVarChar }\n\n  switch (typeof value) {\n    case 'string':\n      for (var item of Array.from(map)) {\n        if (item.js === String) {\n          return item.sql\n        }\n      }\n\n      return TYPES.NVarChar\n\n    case 'number':\n      for (item of Array.from(map)) {\n        if (item.js === Number) {\n          return item.sql\n        }\n      }\n\n      return TYPES.Int\n\n    case 'boolean':\n      for (item of Array.from(map)) {\n        if (item.js === Boolean) {\n          return item.sql\n        }\n      }\n\n      return TYPES.Bit\n\n    case 'object':\n      for (item of Array.from(map)) {\n        if (value instanceof item.js) {\n          return item.sql\n        }\n      }\n\n      return TYPES.NVarChar\n\n    default:\n      return TYPES.NVarChar\n  }\n}\n\n/**\n * Class ConnectionPool.\n *\n * Internally, each `Connection` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool.\n *\n * @property {Boolean} connected If true, connection is established.\n * @property {Boolean} connecting If true, connection is being established.\n *\n * @fires ConnectionPool#connect\n * @fires ConnectionPool#close\n */\n\nclass ConnectionPool extends EventEmitter {\n  /**\n   * Create new Connection.\n   *\n   * @param {Object|String} config Connection configuration object or connection string.\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred.\n   */\n\n  constructor (config, callback) {\n    super()\n\n    this.config = config\n    this._connected = false\n    this._connecting = false\n\n    if (typeof this.config === 'string') {\n      try {\n        this.config = ConnectionString.resolve(this.config, driver.name)\n      } catch (ex) {\n        if (typeof callback === 'function') {\n          return callback(ex)\n        }\n        throw ex\n      }\n    }\n\n    // set defaults\n    this.config.port = this.config.port || 1433\n    this.config.options = this.config.options || {}\n    this.config.stream = this.config.stream || false\n    this.config.parseJSON = this.config.parseJSON || false\n\n    if (/^(.*)\\\\(.*)$/.exec(this.config.server)) {\n      this.config.server = RegExp.$1\n      this.config.options.instanceName = RegExp.$2\n    }\n\n    if (typeof callback === 'function') {\n      this.connect(callback)\n    }\n  }\n\n  get connected () {\n    return this._connected\n  }\n\n  get connecting () {\n    return this._connecting\n  }\n\n  /**\n   * Acquire connection from this connection pool.\n   *\n   * @param {ConnectionPool|Transaction|PreparedStatement} requester Requester.\n   * @param {acquireCallback} [callback] A callback which is called after connection has been acquired, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n  acquire (requester, callback) {\n    debug('conn: acquire')\n\n    if (typeof callback === 'function') {\n      this._acquire().then(connection => callback(null, connection)).catch(callback)\n      return this\n    }\n\n    return this._acquire()\n  }\n\n  _acquire () {\n    if (!this.pool) {\n      return Promise.reject(new ConnectionError('Connection not yet open.', 'ENOTOPEN'))\n    }\n\n    return this.pool.acquire()\n  }\n\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {ConnectionPool}\n   */\n\n  release (connection) {\n    debug('conn: release')\n\n    this.pool.release(connection)\n    return this\n  }\n\n  /**\n   * Creates a new connection pool with one active connection. This one initial connection serves as a probe to find out whether the configuration is valid.\n   *\n   * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n  connect (callback) {\n    if (typeof callback === 'function') {\n      this._connect(callback)\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      return this._connect(err => {\n        if (err) return reject(err)\n        resolve(this)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n  _connect (callback) {\n    if (this._connected) {\n      return callback(new ConnectionError('Database is already connected! Call close before connecting to different database.', 'EALREADYCONNECTED'))\n    }\n\n    if (this._connecting) {\n      return callback(new ConnectionError('Already connecting to database! Call close before connecting to different database.', 'EALREADYCONNECTING'))\n    }\n\n    this._connecting = true\n\n    // create one testing connection to check if everything is ok\n    this._poolCreate().then((connection) => {\n      this._poolDestroy(connection)\n      if (!this._connecting) {\n        // close was called before connection was established\n        return // exit silently\n      }\n\n      // prepare pool\n      this.pool = gp.createPool({\n        create: this._poolCreate.bind(this),\n        validate: this._poolValidate.bind(this),\n        destroy: this._poolDestroy.bind(this)\n      }, Object.assign({\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000,\n        testOnBorrow: true,\n        autostart: false\n      }, this.config.pool))\n\n      this.pool.on('factoryCreateError', this.emit.bind(this, 'error'))\n      this.pool.on('factoryDestroyError', this.emit.bind(this, 'error'))\n\n      this._connecting = false\n      this._connected = true\n\n      callback(null)\n    }).catch(err => {\n      this._connecting = false\n      callback(err)\n    })\n  }\n\n   /**\n   * Close all active connections in the pool.\n   *\n   * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n   * @return {ConnectionPool|Promise}\n   */\n\n  close (callback) {\n    if (typeof callback === 'function') {\n      this._close(callback)\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._close(err => {\n        if (err) return reject(err)\n        resolve(this)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n  _close (callback) {\n    this._connecting = this._connected = false\n\n    if (!this.pool) return setImmediate(callback, null)\n\n    const pool = this.pool\n    this.pool.drain().then(() => {\n      pool.clear()\n      callback(null)\n    })\n\n    this.pool = null\n  }\n\n  /**\n   * Returns new request using this connection.\n   *\n   * @return {Request}\n   */\n\n  request () {\n    return new driver.Request(this)\n  }\n\n  /**\n   * Returns new transaction using this connection.\n   *\n   * @return {Transaction}\n   */\n\n  transaction () {\n    return new driver.Transaction(this)\n  }\n\n  /**\n   * Creates a new query using this connection from a tagged template string.\n   *\n   * @param {Array} strings Array of string literals.\n   * @param {...*} keys Values.\n   * @return {Request}\n   */\n\n  query () {\n    const values = Array.prototype.slice.call(arguments)\n    const strings = values.shift()\n\n    return new driver.Request(this)._template('query', strings, values)\n  }\n\n  /**\n   * Creates a new batch using this connection from a tagged template string.\n   *\n   * @param {Array} strings Array of string literals.\n   * @param {...*} keys Values.\n   * @return {Request}\n   */\n\n  batch () {\n    const values = Array.prototype.slice.call(arguments)\n    const strings = values.shift()\n\n    return new driver.Request(this)._template('batch', strings, values)\n  }\n}\n\n/**\n * Class PreparedStatement.\n *\n * IMPORTANT: Rememeber that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n *\n * @property {String} statement Prepared SQL statement.\n */\n\nclass PreparedStatement extends EventEmitter {\n  /**\n   * Creates a new Prepared Statement.\n   *\n   * @param {ConnectionPool|Transaction} [holder]\n   */\n\n  constructor (parent) {\n    super()\n\n    this.parent = parent || globalConnection\n    this._handle = 0\n    this.prepared = false\n    this.parameters = {}\n  }\n\n  get connected () {\n    return this.parent.connected\n  }\n\n  /**\n   * Acquire connection from connection pool.\n   *\n   * @param {Request} request Request.\n   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n  acquire (request, callback) {\n    debug('ps: acquire')\n\n    if (!this._acquiredConnection) {\n      setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'))\n      return this\n    }\n\n    if (this._activeRequest) {\n      setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'))\n      return this\n    }\n\n    debug('ps: acquire ok')\n\n    this._activeRequest = request\n    setImmediate(callback, null, this._acquiredConnection)\n    return this\n  }\n\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {PreparedStatement}\n   */\n\n  release (connection) {\n    debug('ps: release')\n\n    if (connection === this._acquiredConnection) {\n      this._activeRequest = null\n      debug('ps: release ok')\n    }\n\n    return this\n  }\n\n  /**\n   * Add an input parameter to the prepared statement.\n   *\n   * @param {String} name Name of the input parameter without @ char.\n   * @param {*} type SQL data type of input parameter.\n   * @return {PreparedStatement}\n   */\n\n  input (name, type) {\n    if ((/(--| |\\/\\*|\\*\\/|')/).test(name)) {\n      throw new PreparedStatementError(`SQL injection warning for param '${name}'`, 'EINJECT')\n    }\n\n    if (arguments.length < 2) {\n      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS')\n    }\n\n    if (type instanceof Function) {\n      type = type()\n    }\n\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 1,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision,\n      tvpType: type.tvpType\n    }\n\n    return this\n  }\n\n  /**\n   * Add an output parameter to the prepared statement.\n   *\n   * @param {String} name Name of the output parameter without @ char.\n   * @param {*} type SQL data type of output parameter.\n   * @return {PreparedStatement}\n   */\n\n  output (name, type) {\n    if (/(--| |\\/\\*|\\*\\/|')/.test(name)) {\n      throw new PreparedStatementError(`SQL injection warning for param '${name}'`, 'EINJECT')\n    }\n\n    if (arguments.length < 2) {\n      throw new PreparedStatementError('Invalid number of arguments. 2 arguments expected.', 'EARGS')\n    }\n\n    if (type instanceof Function) type = type()\n\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 2,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision\n    }\n\n    return this\n  }\n\n  /**\n   * Prepare a statement.\n   *\n   * @param {String} statement SQL statement to prepare.\n   * @param {basicCallback} [callback] A callback which is called after preparation has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n  prepare (statement, callback) {\n    if (typeof callback === 'function') {\n      this._prepare(statement, callback)\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._prepare(statement, err => {\n        if (err) return reject(err)\n        resolve(this)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {String} statement\n   * @param {basicCallback} callback\n   */\n\n  _prepare (statement, callback) {\n    debug('ps: prepare')\n\n    if (typeof statement === 'function') {\n      callback = statement\n      statement = undefined\n    }\n\n    if (this.prepared) {\n      return setImmediate(callback, new PreparedStatementError('Statement is already prepared.', 'EALREADYPREPARED'))\n    }\n\n    this.statement = statement || this.statement\n\n    this.parent.acquire(this, (err, connection) => {\n      if (err) return callback(err)\n\n      this._acquiredConnection = connection\n\n      const req = new driver.Request(this)\n      req.stream = false\n      req.output('handle', TYPES.Int)\n      req.input('params', TYPES.NVarChar, ((() => {\n        let result = []\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          result.push(`@${name} ${declare(param.type, param)}${param.io === 2 ? ' output' : ''}`)\n        }\n        return result\n      })()).join(','))\n      req.input('stmt', TYPES.NVarChar, this.statement)\n      req.execute('sp_prepare', (err, result) => {\n        if (err) {\n          this.parent.release(this._acquiredConnection)\n          this._acquiredConnection = null\n\n          return callback(err)\n        }\n\n        debug('ps: prepare ok')\n\n        this._handle = result.output.handle\n        this.prepared = true\n\n        callback(null)\n      })\n    })\n  }\n\n  /**\n   * Execute a prepared statement.\n   *\n   * @param {Object} values An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n   * @param {basicCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n  execute (values, callback) {\n    if (this.stream || (typeof callback === 'function')) {\n      return this._execute(values, callback)\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._execute(values, (err, recordset) => {\n        if (err) return reject(err)\n        resolve(recordset)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {Object} values\n   * @param {basicCallback} callback\n   */\n\n  _execute (values, callback) {\n    const req = new driver.Request(this)\n    req.stream = this.stream\n    req.input('handle', TYPES.Int, this._handle)\n\n    // copy parameters with new values\n    for (let name in this.parameters) {\n      let param = this.parameters[name]\n      req.parameters[name] = {\n        name,\n        type: param.type,\n        io: param.io,\n        value: values[name],\n        length: param.length,\n        scale: param.scale,\n        precision: param.precision\n      }\n    }\n\n    req.execute('sp_execute', (err, result) => {\n      if (err) return callback(err)\n\n      callback(null, result)\n    })\n\n    return req\n  }\n\n  /**\n   * Unprepare a prepared statement.\n   *\n   * @param {basicCallback} [callback] A callback which is called after unpreparation has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {PreparedStatement|Promise}\n   */\n\n  unprepare (callback) {\n    if (typeof callback === 'function') {\n      this._unprepare(callback)\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._unprepare(err => {\n        if (err) return reject(err)\n        resolve()\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {basicCallback} callback\n   */\n\n  _unprepare (callback) {\n    debug('ps: unprepare')\n\n    if (!this.prepared) {\n      return setImmediate(callback, new PreparedStatementError('Statement is not prepared. Call prepare() first.', 'ENOTPREPARED'))\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't unprepare the statement. There is a request in progress.\", 'EREQINPROG'))\n    }\n\n    const req = new driver.Request(this)\n    req.stream = false\n    req.input('handle', TYPES.Int, this._handle)\n    req.execute('sp_unprepare', err => {\n      if (err) return callback(err)\n\n      this.parent.release(this._acquiredConnection)\n      this._acquiredConnection = null\n      this._handle = 0\n      this.prepared = false\n\n      debug('ps: unprepare ok')\n\n      return callback(null)\n    })\n  }\n}\n\n/**\n * Class Transaction.\n *\n * @property {Number} isolationLevel Controls the locking and row versioning behavior of TSQL statements issued by a connection. READ_COMMITTED by default.\n * @property {String} name Transaction name. Empty string by default.\n *\n * @fires Transaction#begin\n * @fires Transaction#commit\n * @fires Transaction#rollback\n */\n\nclass Transaction extends EventEmitter {\n  /**\n   * Create new Transaction.\n   *\n   * @param {Connection} [holder] If ommited, global connection is used instead.\n   */\n\n  constructor (parent) {\n    super()\n\n    this.parent = parent || globalConnection\n    this.isolationLevel = ISOLATION_LEVEL.READ_COMMITTED\n    this.name = ''\n  }\n\n  get connected () {\n    return this.parent.connected\n  }\n\n  /**\n   * Acquire connection from connection pool.\n   *\n   * @param {Request} request Request.\n   * @param {ConnectionPool~acquireCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n  acquire (request, callback) {\n    debug('tran: acquire')\n\n    if (!this._acquiredConnection) {\n      setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'))\n      return this\n    }\n\n    if (this._activeRequest) {\n      setImmediate(callback, new TransactionError(\"Can't acquire connection for the request. There is another request in progress.\", 'EREQINPROG'))\n      return this\n    }\n\n    debug('tran: acquire ok')\n\n    this._activeRequest = request\n    setImmediate(callback, null, this._acquiredConnection)\n    return this\n  }\n\n  /**\n   * Release connection back to the pool.\n   *\n   * @param {Connection} connection Previously acquired connection.\n   * @return {Transaction}\n   */\n\n  release (connection) {\n    debug('tran: release')\n\n    if (connection === this._acquiredConnection) {\n      this._activeRequest = null\n      debug('tran: release ok')\n    }\n\n    return this\n  }\n\n  /**\n   * Begin a transaction.\n   *\n   * @param {Number} [isolationLevel] Controls the locking and row versioning behavior of TSQL statements issued by a connection.\n   * @param {basicCallback} [callback] A callback which is called after transaction has began, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n  begin (isolationLevel, callback) {\n    if (isolationLevel instanceof Function) {\n      callback = isolationLevel\n      isolationLevel = undefined\n    }\n\n    if (typeof callback === 'function') {\n      this._begin(isolationLevel, err => {\n        if (!err) {\n          this.emit('begin')\n          debug('tran: begin ok')\n        }\n        callback(err)\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._begin(isolationLevel, err => {\n        if (err) return reject(err)\n        this.emit('begin')\n        debug('tran: begin ok')\n        resolve(this)\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {Number} [isolationLevel]\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n  _begin (isolationLevel, callback) {\n    debug('tran: begin')\n\n    if (this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has already begun.', 'EALREADYBEGUN'))\n    }\n\n    this._aborted = false\n    this._rollbackRequested = false\n    this.isolationLevel = isolationLevel || this.isolationLevel\n\n    setImmediate(callback)\n  }\n\n  /**\n   * Commit a transaction.\n   *\n   * @param {basicCallback} [callback] A callback which is called after transaction has commited, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n  commit (callback) {\n    if (typeof callback === 'function') {\n      this._commit(err => {\n        if (!err) {\n          this.emit('commit')\n          debug('tran: commit')\n        }\n        callback(err)\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._commit(err => {\n        if (err) return reject(err)\n        this.emit('commit')\n        debug('tran: commit')\n        resolve()\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n  _commit (callback) {\n    debug('tran: commit')\n\n    if (this._aborted) {\n      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'))\n    }\n\n    if (!this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'))\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't commit transaction. There is a request in progress.\", 'EREQINPROG'))\n    }\n\n    setImmediate(callback)\n  }\n\n  /**\n   * Returns new request using this transaction.\n   *\n   * @return {Request}\n   */\n\n  request () {\n    return new driver.Request(this)\n  }\n\n  /**\n   * Rollback a transaction.\n   *\n   * @param {basicCallback} [callback] A callback which is called after transaction has rolled back, or an error has occurred. If omited, method returns Promise.\n   * @return {Transaction|Promise}\n   */\n\n  rollback (callback) {\n    if (typeof callback === 'function') {\n      this._rollback(err => {\n        if (!err) {\n          this.emit('rollback', this._aborted)\n          debug('tran: rollback ok')\n        }\n        callback(err)\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      return this._rollback(err => {\n        if (err) return reject(err)\n        this.emit('rollback', this._aborted)\n        debug('tran: rollback ok')\n        resolve()\n      })\n    }\n    )\n  }\n\n  /**\n   * @private\n   * @param {basicCallback} [callback]\n   * @return {Transaction}\n   */\n\n  _rollback (callback) {\n    debug('tran: rollback')\n\n    if (this._aborted) {\n      return setImmediate(callback, new TransactionError('Transaction has been aborted.', 'EABORT'))\n    }\n\n    if (!this._acquiredConnection) {\n      return setImmediate(callback, new TransactionError('Transaction has not begun. Call begin() first.', 'ENOTBEGUN'))\n    }\n\n    if (this._activeRequest) {\n      return setImmediate(callback, new TransactionError(\"Can't rollback transaction. There is a request in progress.\", 'EREQINPROG'))\n    }\n\n    this._rollbackRequested = true\n\n    setImmediate(callback)\n  }\n}\n\n/**\n * Class Request.\n *\n * @property {Transaction} transaction Reference to transaction when request was created in transaction.\n * @property {*} parameters Collection of input and output parameters.\n * @property {Boolean} canceled `true` if request was canceled.\n *\n * @fires Request#recordset\n * @fires Request#row\n * @fires Request#done\n * @fires Request#error\n */\n\nclass Request extends EventEmitter {\n  /**\n   * Create new Request.\n   *\n   * @param {Connection|ConnectionPool|Transaction|PreparedStatement} parent If ommited, global connection is used instead.\n   */\n\n  constructor (parent) {\n    super()\n\n    this.canceled = false\n    this.parent = parent || globalConnection\n    this.parameters = {}\n  }\n\n  /**\n   * Fetch request from tagged template string.\n   *\n   * @private\n   * @param {String} method\n   * @param {Array} strings\n   * @param {Array} values\n   * @return {Request}\n   */\n\n  _template (method, strings, values) {\n    let command = [strings[0]]\n\n    for (let index = 0; index < values.length; index++) {\n      let value = values[index]\n      this.input(`param${index + 1}`, value)\n      command.push(`@param${index + 1}`, strings[index + 1])\n    }\n\n    return this[method](command.join(''))\n  }\n\n  /**\n   * Add an input parameter to the request.\n   *\n   * @param {String} name Name of the input parameter without @ char.\n   * @param {*} [type] SQL data type of input parameter. If you omit type, module automaticaly decide which SQL data type should be used based on JS data type.\n   * @param {*} value Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n   * @return {Request}\n   */\n\n  input (name, type, value) {\n    if ((/(--| |\\/\\*|\\*\\/|')/).test(name)) {\n      throw new RequestError(`SQL injection warning for param '${name}'`, 'EINJECT')\n    }\n\n    if (arguments.length === 1) {\n      throw new RequestError('Invalid number of arguments. At least 2 arguments expected.', 'EARGS')\n    } else if (arguments.length === 2) {\n      value = type\n      type = getTypeByValue(value)\n    }\n\n    // support for custom data types\n    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf()\n\n    if (value === undefined) value = null // undefined to null\n    if (typeof value === 'number' && isNaN(value)) value = null // NaN to null\n    if (type instanceof Function) type = type()\n\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 1,\n      value,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision,\n      tvpType: type.tvpType\n    }\n\n    return this\n  }\n\n  /**\n   * Add an output parameter to the request.\n   *\n   * @param {String} name Name of the output parameter without @ char.\n   * @param {*} type SQL data type of output parameter.\n   * @param {*} [value] Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n   * @return {Request}\n   */\n\n  output (name, type, value) {\n    if (!type) { type = TYPES.NVarChar }\n\n    if ((/(--| |\\/\\*|\\*\\/|')/).test(name)) {\n      throw new RequestError(`SQL injection warning for param '${name}'`, 'EINJECT')\n    }\n\n    if ((type === TYPES.Text) || (type === TYPES.NText) || (type === TYPES.Image)) {\n      throw new RequestError('Deprecated types (Text, NText, Image) are not supported as OUTPUT parameters.', 'EDEPRECATED')\n    }\n\n    // support for custom data types\n    if (value && typeof value.valueOf === 'function' && !(value instanceof Date)) value = value.valueOf()\n\n    if (value === undefined) value = null // undefined to null\n    if (typeof value === 'number' && isNaN(value)) value = null // NaN to null\n    if (type instanceof Function) type = type()\n\n    this.parameters[name] = {\n      name,\n      type: type.type,\n      io: 2,\n      value,\n      length: type.length,\n      scale: type.scale,\n      precision: type.precision\n    }\n\n    return this\n  }\n\n  /**\n   * Execute the SQL batch.\n   *\n   * @param {String} batch T-SQL batch to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n  batch (batch, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream\n    this.rowsAffected = 0\n\n    if (typeof callback === 'function') {\n      this._batch(batch, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected\n          })\n        }\n\n        if (err) return callback(err)\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        })\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._batch(batch, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected\n          })\n        }\n\n        if (err) return reject(err)\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        })\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {String} batch\n   * @param {Request~requestCallback} callback\n   */\n\n  _batch (batch, callback) {\n    if (!this.connection) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))\n    }\n\n    if (!this.connection.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))\n    }\n\n    this.canceled = false\n    setImmediate(callback)\n  }\n\n  /**\n   * Bulk load.\n   *\n   * @param {Table} table SQL table.\n   * @param {Request~bulkCallback} [callback] A callback which is called after bulk load has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n  bulk (table, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream\n\n    if (this.stream || typeof callback === 'function') {\n      this._bulk(table, (err, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          return this.emit('done', {\n            rowsAffected\n          })\n        }\n\n        if (err) return callback(err)\n        callback(null, {\n          rowsAffected\n        })\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._bulk(table, (err, rowsAffected) => {\n        if (err) return reject(err)\n        resolve({\n          rowsAffected\n        })\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {Table} table\n   * @param {Request~bulkCallback} callback\n   */\n\n  _bulk (table, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))\n    }\n\n    this.canceled = false\n    setImmediate(callback)\n  }\n\n  /**\n   * Sets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n   *\n   * @param {Stream} stream Stream to pipe data into.\n   * @return {Stream}\n   */\n\n  pipe (stream) {\n    this.stream = true\n    this.on('row', stream.write.bind(stream))\n    this.on('error', stream.emit.bind(stream, 'error'))\n    this.on('done', () => {\n      setImmediate(() => stream.end())\n    })\n    stream.emit('pipe', this)\n    return stream\n  }\n\n  /**\n   * Execute the SQL command.\n   *\n   * @param {String} command T-SQL command to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n  query (command, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream\n    this.rowsAffected = 0\n\n    if (typeof callback === 'function') {\n      this._query(command, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected\n          })\n        }\n\n        if (err) return callback(err)\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        })\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._query(command, (err, recordsets, output, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected\n          })\n        }\n\n        if (err) return reject(err)\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected\n        })\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {String} command\n   * @param {Request~bulkCallback} callback\n   */\n\n  _query (command, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))\n    }\n\n    this.canceled = false\n    setImmediate(callback)\n  }\n\n  /**\n   * Call a stored procedure.\n   *\n   * @param {String} procedure Name of the stored procedure to be executed.\n   * @param {Request~requestCallback} [callback] A callback which is called after execution has completed, or an error has occurred. If omited, method returns Promise.\n   * @return {Request|Promise}\n   */\n\n  execute (command, callback) {\n    if (this.stream == null && this.connection) this.stream = this.connection.config.stream\n    this.rowsAffected = 0\n\n    if (typeof callback === 'function') {\n      this._execute(command, (err, recordsets, output, returnValue, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected,\n            returnValue\n          })\n        }\n\n        if (err) return callback(err)\n        callback(null, {\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected,\n          returnValue\n        })\n      })\n      return this\n    }\n\n    return new PromiseLibrary((resolve, reject) => {\n      this._execute(command, (err, recordsets, output, returnValue, rowsAffected) => {\n        if (this.stream) {\n          if (err) this.emit('error', err)\n          err = null\n\n          this.emit('done', {\n            output,\n            rowsAffected,\n            returnValue\n          })\n        }\n\n        if (err) return reject(err)\n        resolve({\n          recordsets,\n          recordset: recordsets && recordsets[0],\n          output,\n          rowsAffected,\n          returnValue\n        })\n      })\n    })\n  }\n\n  /**\n   * @private\n   * @param {String} procedure\n   * @param {Request~bulkCallback} callback\n   */\n\n  _execute (procedure, callback) {\n    if (!this.parent) {\n      return setImmediate(callback, new RequestError('No connection is specified for that request.', 'ENOCONN'))\n    }\n\n    if (!this.parent.connected) {\n      return setImmediate(callback, new ConnectionError('Connection is closed.', 'ECONNCLOSED'))\n    }\n\n    this.canceled = false\n    setImmediate(callback)\n  }\n\n  /**\n   * Cancel currently executed request.\n   *\n   * @return {Boolean}\n   */\n\n  cancel () {\n    this._cancel()\n    return true\n  }\n\n  /**\n   * @private\n   */\n\n  _cancel () {\n    this.canceled = true\n  }\n}\n\n/**\n * Class ConnectionError.\n */\n\nclass ConnectionError extends Error {\n  /**\n   * Creates a new ConnectionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n\n  constructor (message, code) {\n    if (message instanceof Error) {\n      super(message.message)\n      this.code = message.code || code\n\n      Object.defineProperty(this, 'originalError', {enumerable: true, value: message})\n    } else {\n      super(message)\n      this.code = code\n    }\n\n    this.name = 'ConnectionError'\n  }\n}\n\n/**\n * Class TransactionError.\n */\n\nclass TransactionError extends Error {\n  /**\n   * Creates a new TransactionError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n\n  constructor (message, code) {\n    if (message instanceof Error) {\n      super(message.message)\n      this.code = message.code || code\n\n      Object.defineProperty(this, 'originalError', {enumerable: true, value: message})\n    } else {\n      super(message)\n      this.code = code\n    }\n\n    this.name = 'TransactionError'\n  }\n}\n\n/**\n * Class RequestError.\n *\n * @property {String} number Error number.\n * @property {Number} lineNumber Line number.\n * @property {String} state Error state.\n * @property {String} class Error class.\n * @property {String} serverName Server name.\n * @property {String} procName Procedure name.\n */\n\nclass RequestError extends Error {\n  /**\n   * Creates a new RequestError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n\n  constructor (message, code) {\n    if (message instanceof Error) {\n      super(message.message)\n      this.code = message.code || code\n\n      if (message.info) {\n        this.number = message.info.number || message.code // err.code is returned by msnodesql driver\n        this.lineNumber = message.info.lineNumber\n        this.state = message.info.state || message.sqlstate // err.sqlstate is returned by msnodesql driver\n        this.class = message.info.class\n        this.serverName = message.info.serverName\n        this.procName = message.info.procName\n      } else {\n        this.number = message.code // err.code is returned by msnodesql driver\n        this.state = message.sqlstate // err.sqlstate is returned by msnodesql driver\n      }\n\n      Object.defineProperty(this, 'originalError', {enumerable: true, value: message})\n    } else {\n      super(message)\n      this.code = code\n    }\n\n    this.name = 'RequestError'\n    if ((/^\\[Microsoft\\]\\[SQL Server Native Client 11\\.0\\](?:\\[SQL Server\\])?([\\s\\S]*)$/).exec(this.message)) {\n      this.message = RegExp.$1\n    }\n  }\n}\n\n/**\n * Class PreparedStatementError.\n */\n\nclass PreparedStatementError extends Error {\n  /**\n   * Creates a new PreparedStatementError.\n   *\n   * @param {String} message Error message.\n   * @param {String} [code] Error code.\n   */\n\n  constructor (message, code) {\n    if (message instanceof Error) {\n      super(message.message)\n      this.code = message.code || code\n\n      Object.defineProperty(this, 'originalError', {enumerable: true, value: message})\n    } else {\n      super(message)\n      this.code = code\n    }\n\n    this.name = 'PreparedStatementError'\n  }\n}\n\nmodule.exports = {\n  ConnectionPool,\n  Transaction,\n  Request,\n  PreparedStatement,\n  ConnectionError,\n  TransactionError,\n  RequestError,\n  PreparedStatementError,\n  driver,\n  exports: {\n    ConnectionError,\n    TransactionError,\n    RequestError,\n    PreparedStatementError,\n    Table,\n    ISOLATION_LEVEL,\n    TYPES,\n    MAX: 65535, // (1 << 16) - 1\n    map\n  }\n}\n\nObject.defineProperty(module.exports, 'Promise', {\n  get: () => {\n    return PromiseLibrary\n  },\n  set: (value) => {\n    PromiseLibrary = value\n  }\n})\n\n// append datatypes to this modules export\n\nfor (let key in TYPES) {\n  let value = TYPES[key]\n  module.exports.exports[key] = value\n  module.exports.exports[key.toUpperCase()] = value\n}\n\n/**\n * Open global connection pool.\n *\n * @param {Object|String} config Connection configuration object or connection string.\n * @param {basicCallback} [callback] A callback which is called after connection has established, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\nmodule.exports.exports.connect = function connect (config, callback) {\n  if (globalConnection) throw new Error('Global connection already exists. Call sql.close() first.')\n  globalConnection = new driver.ConnectionPool(config)\n\n  for (let event in globalConnectionHandlers) {\n    for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n      globalConnection.on(event, globalConnectionHandlers[event][i])\n    }\n  }\n\n  return globalConnection.connect(callback)\n}\n\n/**\n * Close all active connections in the global pool.\n *\n * @param {basicCallback} [callback] A callback which is called after connection has closed, or an error has occurred. If omited, method returns Promise.\n * @return {ConnectionPool|Promise}\n */\n\nmodule.exports.exports.close = function close (callback) {\n  if (globalConnection) {\n    // remove event handlers from the global connection\n    for (let event in globalConnectionHandlers) {\n      for (let i = 0, l = globalConnectionHandlers[event].length; i < l; i++) {\n        globalConnection.removeListener(event, globalConnectionHandlers[event][i])\n      }\n    }\n\n    // attach error handler to prevent process crash in case of error\n    globalConnection.on('error', err => {\n      if (globalConnectionHandlers['error']) {\n        for (let i = 0, l = globalConnectionHandlers['error'].length; i < l; i++) {\n          globalConnectionHandlers['error'][i].call(globalConnection, err)\n        }\n      }\n    })\n\n    const gc = globalConnection\n    globalConnection = null\n    return gc.close(callback)\n  }\n\n  if (typeof callback === 'function') {\n    setImmediate(callback)\n    return null\n  }\n\n  return new PromiseLibrary((resolve, reject) => {\n    resolve(globalConnection)\n  })\n}\n\n/**\n * Attach event handler to global connection pool.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\nmodule.exports.exports.on = function on (event, handler) {\n  if (!globalConnectionHandlers[event]) globalConnectionHandlers[event] = []\n  globalConnectionHandlers[event].push(handler)\n\n  if (globalConnection) globalConnection.on(event, handler)\n  return globalConnection\n}\n\n/**\n * Detach event handler from global connection.\n *\n * @param {String} event Event name.\n * @param {Function} handler Event handler.\n * @return {ConnectionPool}\n */\n\nmodule.exports.exports.removeListener = module.exports.exports.off = function removeListener (event, handler) {\n  if (!globalConnectionHandlers[event]) return globalConnection\n  const index = globalConnectionHandlers[event].indexOf(handler)\n  if (index === -1) return globalConnection\n  globalConnectionHandlers[event].splice(index, 1)\n  if (globalConnectionHandlers[event].length === 0) globalConnectionHandlers[event] = undefined\n\n  if (globalConnection) globalConnection.removeListener(event, handler)\n  return globalConnection\n}\n\n/**\n * Creates a new query using global connection from a tagged template string.\n *\n * @param {Array} strings Array of string literals.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\nmodule.exports.exports.query = function query () {\n  const values = Array.prototype.slice.call(arguments)\n  const strings = values.shift()\n\n  return new driver.Request()._template('query', strings, values)\n}\n\n/**\n * Creates a new batch using global connection from a tagged template string.\n *\n * @param {Array} strings Array of string literals.\n * @param {...*} keys Values.\n * @return {Request}\n */\n\nmodule.exports.exports.batch = function batch () {\n  const values = Array.prototype.slice.call(arguments)\n  const strings = values.shift()\n\n  return new driver.Request()._template('batch', strings, values)\n}\n\n/**\n * @callback Request~requestCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Object} result Request result.\n */\n\n/**\n * @callback Request~bulkCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Number} rowsAffected Number of affected rows.\n */\n\n/**\n * @callback basicCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * @callback acquireCallback\n * @param {Error} err Error on error, otherwise null.\n * @param {Connection} connection Acquired connection.\n */\n\n/**\n * Dispatched after connection has established.\n * @event ConnectionPool#connect\n */\n\n/**\n * Dispatched after connection has closed a pool (by calling close).\n * @event ConnectionPool#close\n */\n\n/**\n * Dispatched when transaction begin.\n * @event Transaction#begin\n */\n\n/**\n * Dispatched on successful commit.\n * @event Transaction#commit\n */\n\n/**\n * Dispatched on successful rollback.\n * @event Transaction#rollback\n */\n\n/**\n * Dispatched when metadata for new recordset are parsed.\n * @event Request#recordset\n */\n\n/**\n * Dispatched when new row is parsed.\n * @event Request#row\n */\n\n/**\n * Dispatched when request is complete.\n * @event Request#done\n */\n\n/**\n * Dispatched on error.\n * @event Request#error\n */\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/datatypes.js":"'use strict'\n\nconst TYPES = {\n  VarChar (length) {\n    return {type: TYPES.VarChar, length}\n  },\n  NVarChar (length) {\n    return {type: TYPES.NVarChar, length}\n  },\n  Text () {\n    return {type: TYPES.Text}\n  },\n  Int () {\n    return {type: TYPES.Int}\n  },\n  BigInt () {\n    return {type: TYPES.BigInt}\n  },\n  TinyInt () {\n    return {type: TYPES.TinyInt}\n  },\n  SmallInt () {\n    return {type: TYPES.SmallInt}\n  },\n  Bit () {\n    return {type: TYPES.Bit}\n  },\n  Float () {\n    return {type: TYPES.Float}\n  },\n  Numeric (precision, scale) {\n    return {type: TYPES.Numeric, precision, scale}\n  },\n  Decimal (precision, scale) {\n    return {type: TYPES.Decimal, precision, scale}\n  },\n  Real () {\n    return {type: TYPES.Real}\n  },\n  Date () {\n    return {type: TYPES.Date}\n  },\n  DateTime () {\n    return {type: TYPES.DateTime}\n  },\n  DateTime2 (scale) {\n    return {type: TYPES.DateTime2, scale}\n  },\n  DateTimeOffset (scale) {\n    return {type: TYPES.DateTimeOffset, scale}\n  },\n  SmallDateTime () {\n    return {type: TYPES.SmallDateTime}\n  },\n  Time (scale) {\n    return {type: TYPES.Time, scale}\n  },\n  UniqueIdentifier () {\n    return {type: TYPES.UniqueIdentifier}\n  },\n  SmallMoney () {\n    return {type: TYPES.SmallMoney}\n  },\n  Money () {\n    return {type: TYPES.Money}\n  },\n  Binary (length) {\n    return {type: TYPES.Binary, length}\n  },\n  VarBinary (length) {\n    return {type: TYPES.VarBinary, length}\n  },\n  Image () {\n    return {type: TYPES.Image}\n  },\n  Xml () {\n    return {type: TYPES.Xml}\n  },\n  Char (length) {\n    return {type: TYPES.Char, length}\n  },\n  NChar (length) {\n    return {type: TYPES.NChar, length}\n  },\n  NText () {\n    return {type: TYPES.NText}\n  },\n  TVP (tvpType) {\n    return {type: TYPES.TVP, tvpType}\n  },\n  UDT () {\n    return {type: TYPES.UDT}\n  },\n  Geography () {\n    return {type: TYPES.Geography}\n  },\n  Geometry () {\n    return {type: TYPES.Geometry}\n  },\n  Variant () {\n    return {type: TYPES.Variant}\n  }\n}\n\nmodule.exports.TYPES = TYPES\nmodule.exports.DECLARATIONS = {}\n\nconst zero = function (value, length) {\n  if (length == null) length = 2\n\n  value = String(value)\n  if (value.length < length) {\n    for (let i = 1; i <= length - value.length; i++) {\n      value = `0${value}`\n    }\n  }\n  return value\n}\n\nfor (const key in TYPES) {\n  if (Object.prototype.hasOwnProperty.call(TYPES, key)) {\n    const value = TYPES[key]\n    value.declaration = key.toLowerCase()\n    module.exports.DECLARATIONS[value.declaration] = value;\n\n    ((key, value) => {\n      value.inspect = () => `[sql.${key}]`\n    })(key, value)\n  }\n}\n\nmodule.exports.declare = (type, options) => {\n  switch (type) {\n    case TYPES.VarChar: case TYPES.VarBinary:\n      return `${type.declaration} (${options.length > 8000 ? 'MAX' : (options.length == null ? 'MAX' : options.length)})`\n    case TYPES.NVarChar:\n      return `${type.declaration} (${options.length > 4000 ? 'MAX' : (options.length == null ? 'MAX' : options.length)})`\n    case TYPES.Char: case TYPES.NChar: case TYPES.Binary:\n      return `${type.declaration} (${options.length == null ? 1 : options.length})`\n    case TYPES.Decimal: case TYPES.Numeric:\n      return `${type.declaration} (${options.precision == null ? 18 : options.precision}, ${options.scale == null ? 0 : options.scale})`\n    case TYPES.Time: case TYPES.DateTime2: case TYPES.DateTimeOffset:\n      return `${type.declaration} (${options.scale == null ? 7 : options.scale})`\n    case TYPES.TVP:\n      return `${options.tvpType} readonly`\n    default:\n      return type.declaration\n  }\n}\n\nmodule.exports.cast = (value, type, options) => {\n  if (value == null) {\n    return null\n  }\n\n  switch (typeof value) {\n    case 'string':\n      return `N'${value.replace(/'/g, '\\'\\'')}'`\n\n    case 'number':\n      return value\n\n    case 'boolean':\n      return value ? 1 : 0\n\n    case 'object':\n      if (value instanceof Date) {\n        let ns = value.getUTCMilliseconds() / 1000\n        if (value.nanosecondDelta != null) {\n          ns += value.nanosecondDelta\n        }\n        const scale = options.scale == null ? 7 : options.scale\n\n        if (scale > 0) {\n          ns = String(ns).substr(1, scale + 1)\n        } else {\n          ns = ''\n        }\n\n        return `N'${value.getUTCFullYear()}-${zero(value.getUTCMonth() + 1)}-${zero(value.getUTCDate())} ${zero(value.getUTCHours())}:${zero(value.getUTCMinutes())}:${zero(value.getUTCSeconds())}${ns}'`\n      } else if (Buffer.isBuffer(value)) {\n        return `0x${value.toString('hex')}`\n      }\n\n      return null\n\n    default:\n      return null\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/isolationlevel.js":"'use strict'\n\nmodule.exports = {\n  READ_UNCOMMITTED: 0x01,\n  READ_COMMITTED: 0x02,\n  REPEATABLE_READ: 0x03,\n  SERIALIZABLE: 0x04,\n  SNAPSHOT: 0x05\n}\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/table.js":"'use strict'\n\nconst TYPES = require('./datatypes').TYPES\nconst declareType = require('./datatypes').declare\n\nconst MAX = 65535 // (1 << 16) - 1\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nfunction Table (name) {\n  if (name) {\n    const parsed = Table.parseName(name)\n    this.name = parsed.name\n    this.schema = parsed.schema\n    this.database = parsed.database\n    this.path = (this.database ? `[${this.database}].` : '') + (this.schema ? `[${this.schema}].` : '') + `[${this.name}]`\n    this.temporary = this.name.charAt(0) === '#'\n  }\n\n  this.columns = []\n  this.rows = []\n\n  Object.defineProperty(this.columns, 'add', {\n    value (name, column, options) {\n      if (column == null) {\n        throw new Error('Column data type is not defined.')\n      }\n      if (column instanceof Function) {\n        column = column()\n      }\n\n      options = options || {}\n      column.name = name\n      column.nullable = options.nullable\n      column.primary = options.primary\n\n      return this.push(column)\n    }\n  }\n  )\n\n  Object.defineProperty(this.rows, 'add', {\n    value () {\n      return this.push(Array.prototype.slice.call(arguments))\n    }\n  }\n  )\n}\n\n/*\n@private\n*/\n\nTable.prototype._makeBulk = function _makeBulk () {\n  for (let i = 0; i < this.columns.length; i++) {\n    const col = this.columns[i]\n    switch (col.type) {\n      case TYPES.Xml:\n        col.type = TYPES.NVarChar(MAX).type\n        break\n\n      case TYPES.UDT:\n      case TYPES.Geography:\n      case TYPES.Geometry:\n        col.type = TYPES.VarBinary(MAX).type\n        break\n\n      default:\n        break\n    }\n  }\n\n  return this\n}\n\nTable.prototype.declare = function declare () {\n  const pkey = this.columns.filter(col => col.primary === true).map(col => col.name)\n  const cols = this.columns.map(col => {\n    const def = [`[${col.name}] ${declareType(col.type, col)}`]\n\n    if (col.nullable === true) {\n      def.push('null')\n    } else if (col.nullable === false) {\n      def.push('not null')\n    }\n\n    if (col.primary === true && pkey.length === 1) {\n      def.push('primary key')\n    }\n\n    return def.join(' ')\n  })\n\n  const constraint = pkey.length > 1 ? `, constraint PK_${this.temporary ? this.name.substr(1) : this.name} primary key (${pkey.join(', ')})` : ''\n  return `create table ${this.path} (${cols.join(', ')}${constraint})`\n}\n\nTable.fromRecordset = function fromRecordset (recordset, name) {\n  const t = new this(name)\n\n  for (const colName in recordset.columns) {\n    if (Object.prototype.hasOwnProperty.call(recordset.columns, colName)) {\n      const col = recordset.columns[colName]\n\n      t.columns.add(colName, {\n        type: col.type,\n        length: col.length,\n        scale: col.scale,\n        precision: col.precision\n      }, {\n        nullable: col.nullable\n      })\n    }\n  }\n\n  if (t.columns.length === 1 && t.columns[0].name === JSON_COLUMN_ID) {\n    for (let i = 0; i < recordset.length; i++) {\n      t.rows.add(JSON.stringify(recordset[i]))\n    }\n  } else {\n    for (let i = 0; i < recordset.length; i++) {\n      t.rows.add.apply(t.rows, t.columns.map(col => recordset[i][col.name]))\n    }\n  }\n\n  return t\n}\n\nTable.parseName = function parseName (name) {\n  const length = name.length\n  let cursor = -1\n  let buffer = ''\n  let escaped = false\n  const path = []\n\n  while (++cursor < length) {\n    const char = name.charAt(cursor)\n    if (char === '[') {\n      if (escaped) {\n        buffer += char\n      } else {\n        escaped = true\n      }\n    } else if (char === ']') {\n      if (escaped) {\n        escaped = false\n      } else {\n        throw new Error('Invalid table name.')\n      }\n    } else if (char === '.') {\n      if (escaped) {\n        buffer += char\n      } else {\n        path.push(buffer)\n        buffer = ''\n      }\n    } else {\n      buffer += char\n    }\n  }\n\n  if (buffer) {\n    path.push(buffer)\n  }\n\n  switch (path.length) {\n    case 1:\n      return {\n        name: path[0],\n        schema: null,\n        database: null\n      }\n\n    case 2:\n      return {\n        name: path[1],\n        schema: path[0],\n        database: null\n      }\n\n    case 3:\n      return {\n        name: path[2],\n        schema: path[1],\n        database: path[0]\n      }\n\n    default:\n      throw new Error('Invalid table name.')\n  }\n}\n\nmodule.exports = Table\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/connectionstring.js":"'use strict'\n\nconst url = require('url')\nconst qs = require('querystring')\n\nconst IGNORE_KEYS = ['stream']\nconst oror = function () {\n  for (let i = 0, l = arguments.length; i < l; i++) {\n    if (arguments[i] !== null && arguments[i] !== undefined) {\n      return arguments[i]\n    }\n  }\n}\n\nconst parseConnectionURI = function (uri) {\n  const parsed = url.parse(uri)\n  let instance\n  let user\n  let password\n\n  const path = parsed.pathname.substr(1).split('/')\n  if (path.length > 1) {\n    instance = path.shift()\n  }\n\n  if (parsed.auth) {\n    parsed.auth = parsed.auth.split(':')\n    user = parsed.auth.shift()\n    password = parsed.auth.join(':')\n  }\n\n  const port = parsed.port ? `,${parsed.port}` : (instance ? `\\\\${instance}` : '')\n  const object = {\n    server: `${parsed.hostname}${port}`,\n    uid: user || '',\n    pwd: password || '',\n    database: path[0]\n  }\n\n  if (parsed.query) {\n    const query = qs.parse(parsed.query)\n    for (const key in query) {\n      if (Object.prototype.hasOwnProperty.call(query, key)) {\n        const value = query[key]\n        if (key === 'domain') {\n          object.uid = `${value}\\\\${object.uid}`\n        } else {\n          object[key] = value\n        }\n      }\n    }\n  }\n\n  Object.defineProperty(object, 'toString', {\n    value () {\n      const out = []\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          out.push(`${key}={${this[key]}}`)\n        }\n      }\n      return out.join(';')\n    }\n  })\n\n  return object\n}\n\nconst parseConnectionString = function (string) {\n  let cursor = 0\n  let parsing = 'name'\n  let param = null\n  let buffer = ''\n  let quotes = null\n  const parsed = {}\n  const original = {}\n\n  Object.defineProperty(parsed, '__original__', {value: original})\n  Object.defineProperty(parsed, 'toString', {\n    value () {\n      const out = []\n      for (const key in this) {\n        if (IGNORE_KEYS.indexOf(key) === -1) {\n          const esc = original[key].escape || ['', '']\n          out.push(`${original[key].name}=${esc[0] || ''}${this[key]}${esc[1] || ''}`)\n        }\n      }\n      return out.join(';')\n    }\n  })\n\n  while (cursor < string.length) {\n    const char = string.charAt(cursor)\n    switch (char) {\n      case '=':\n        if (parsing === 'name') {\n          buffer = buffer.trim()\n          param = buffer.toLowerCase()\n          original[param] = {name: buffer}\n          parsing = 'value'\n          buffer = ''\n        } else {\n          buffer += char\n        }\n        break\n\n      case '\\'': case '\"':\n        if (parsing === 'value') {\n          if (!buffer.trim().length) {\n            // value is wrapped in qotes\n            original[param].escape = [char, char]\n            quotes = char\n            buffer = ''\n          } else if (quotes) {\n            if (char === quotes) {\n              // found same char as used for wrapping quotes\n              if (char === string.charAt(cursor + 1)) {\n                // escaped quote\n                buffer += char\n                cursor++\n              } else {\n                // end of value\n                parsed[param] = buffer\n                param = null\n                parsing = null\n                buffer = ''\n                quotes = null\n              }\n            } else {\n              buffer += char\n            }\n          } else {\n            buffer += char\n          }\n        } else {\n          throw new Error('Invalid connection string.')\n        }\n        break\n\n      case '{':\n        if (parsing === 'value') {\n          if (buffer.trim().length === 0) {\n            // value is wrapped in qotes\n            original[param].escape = ['{', '}']\n            quotes = '{}'\n            buffer = ''\n          } else {\n            buffer += char\n          }\n        } else {\n          throw new Error('Invalid connection string.')\n        }\n        break\n\n      case '}':\n        if (parsing === 'value') {\n          if (quotes === '{}') {\n            // end of value\n            parsed[param] = buffer\n            param = null\n            parsing = null\n            buffer = ''\n            quotes = null\n          } else {\n            buffer += char\n          }\n        } else {\n          throw new Error('Invalid connection string.')\n        }\n        break\n\n      case ';':\n        if (parsing === 'value') {\n          if (quotes) {\n            buffer += char\n          } else {\n            // end of value\n            parsed[param] = buffer\n            param = null\n            parsing = 'name'\n            buffer = ''\n          }\n        } else {\n          buffer = ''\n          parsing = 'name'\n        }\n        break\n\n      default:\n        buffer += char\n    }\n\n    cursor++\n  }\n\n  if (parsing === 'value') {\n    // end of value\n    parsed[param] = buffer\n  }\n\n  return parsed\n}\n\nconst resolveConnectionString = function (string, driver) {\n  const parsed = /^(mssql|tedious|msnodesql|tds):\\/\\//i.test(string) ? parseConnectionURI(string) : parseConnectionString(string)\n  const stream = (parsed.stream || '').toLowerCase()\n  const encrypt = (parsed.encrypt || '').toLowerCase()\n\n  if (driver === 'msnodesqlv8') {\n    parsed.driver = 'SQL Server Native Client 11.0'\n\n    if (parsed.__original__) {\n      parsed.__original__.driver = {name: 'Driver', escape: ['{', '}']}\n    }\n\n    return {connectionString: parsed.toString()}\n  }\n\n  let user = parsed.uid || parsed.uid || parsed['user id']\n  let server = parsed.server || parsed.address || parsed.addr || parsed['data source'] || parsed['network address']\n\n  const config = {\n    password: oror(parsed.pwd, parsed.password),\n    database: oror(parsed.database, parsed['initial catalog']),\n    connectionTimeout: oror(parsed.connectionTimeout, parsed.timeout, parsed['connect timeout'], parsed['connection timeout']),\n    requestTimeout: oror(parsed.requestTimeout, parsed['request timeout']),\n    stream: stream === 'true' || stream === 'yes' || stream === '1',\n    options: {\n      encrypt: encrypt === 'true' || encrypt === 'yes' || encrypt === '1'\n    }\n  }\n\n  if (parsed.useUTC != null) {\n    const utc = parsed.useUTC.toLowerCase()\n    config.options.useUTC = utc === 'true' || utc === 'yes' || utc === '1'\n  }\n  if (config.connectionTimeout != null) {\n    config.connectionTimeout = parseInt(config.connectionTimeout, 10)\n  }\n  if (config.requestTimeout != null) {\n    config.requestTimeout = parseInt(config.requestTimeout, 10)\n  }\n\n  if (/^(.*)\\\\(.*)$/.exec(user)) {\n    config.domain = RegExp.$1\n    user = RegExp.$2\n  }\n\n  if (server) {\n    server = server.trim()\n\n    if (/^np:/i.test(server)) {\n      throw new Error('Connection via Named Pipes is not supported.')\n    }\n\n    if (/^tcp:/i.test(server)) {\n      server = server.substr(4)\n    }\n\n    if (/^(.*)\\\\(.*)$/.exec(server)) {\n      server = RegExp.$1\n      config.options.instanceName = RegExp.$2\n    }\n\n    if (/^(.*),(.*)$/.exec(server)) {\n      server = RegExp.$1.trim()\n      config.port = parseInt(RegExp.$2.trim(), 10)\n    }\n\n    if (server === '.' || server === '(.)' || server.toLowerCase() === '(localdb)' || server.toLowerCase() === '(local)') {\n      server = 'localhost'\n    }\n  }\n\n  config.user = user\n  config.server = server\n  return config\n}\n\nmodule.exports = {\n  parse: parseConnectionString,\n  resolve: resolveConnectionString\n}\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/udt.js":"'use strict'\n\n/* const FIGURE = {\n  INTERIOR_RING: 0x00,\n  STROKE: 0x01,\n  EXTERIOR_RING: 0x02\n};\n\nconst FIGURE_V2 = {\n  POINT: 0x00,\n  LINE: 0x01,\n  ARC: 0x02,\n  COMPOSITE_CURVE: 0x03\n};\n\nconst SHAPE = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07\n};\n\nconst SHAPE_V2 = {\n  POINT: 0x01,\n  LINESTRING: 0x02,\n  POLYGON: 0x03,\n  MULTIPOINT: 0x04,\n  MULTILINESTRING: 0x05,\n  MULTIPOLYGON: 0x06,\n  GEOMETRY_COLLECTION: 0x07,\n  CIRCULAR_STRING: 0x08,\n  COMPOUND_CURVE: 0x09,\n  CURVE_POLYGON: 0x0A,\n  FULL_GLOBE: 0x0B\n};\n\nconst SEGMENT = {\n  LINE: 0x00,\n  ARC: 0x01,\n  FIRST_LINE: 0x02,\n  FIRST_ARC: 0x03\n}; */\n\nclass Point {\n  constructor () {\n    this.x = 0\n    this.y = 0\n    this.z = null\n    this.m = null\n  }\n}\n\nconst parsePoints = (buffer, count) => {\n  // s2.1.5 + s2.1.6\n\n  const points = []\n  if (count < 1) {\n    return points\n  }\n\n  for (let i = 1; i <= count; i++) {\n    const point = new Point()\n    points.push(point)\n    point.x = buffer.readDoubleLE(buffer.position)\n    point.y = buffer.readDoubleLE(buffer.position + 8)\n    buffer.position += 16\n  }\n\n  return points\n}\n\nconst parseZ = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.z = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseM = (buffer, points) => {\n  // s2.1.1 + s.2.1.2\n\n  if (points < 1) {\n    return\n  }\n\n  points.forEach(point => {\n    point.m = buffer.readDoubleLE(buffer.position)\n    buffer.position += 8\n  })\n}\n\nconst parseFigures = (buffer, count, properties) => {\n  // s2.1.3\n\n  const figures = []\n  if (count < 1) {\n    return figures\n  }\n\n  if (properties.P) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else if (properties.L) {\n    figures.push({\n      attribute: 0x01,\n      pointOffset: 0\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      figures.push({\n        attribute: buffer.readUInt8(buffer.position),\n        pointOffset: buffer.readInt32LE(buffer.position + 1)\n      })\n\n      buffer.position += 5\n    }\n  }\n\n  return figures\n}\n\nconst parseShapes = (buffer, count, properties) => {\n  // s2.1.4\n\n  const shapes = []\n  if (count < 1) {\n    return shapes\n  }\n\n  if (properties.P) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x01\n    })\n  } else if (properties.L) {\n    shapes.push({\n      parentOffset: -1,\n      figureOffset: 0,\n      type: 0x02\n    })\n  } else {\n    for (let i = 1; i <= count; i++) {\n      shapes.push({\n        parentOffset: buffer.readInt32LE(buffer.position),\n        figureOffset: buffer.readInt32LE(buffer.position + 4),\n        type: buffer.readUInt8(buffer.position + 8)\n      })\n\n      buffer.position += 9\n    }\n  }\n\n  return shapes\n}\n\nconst parseSegments = (buffer, count) => {\n  // s2.1.7\n\n  const segments = []\n  if (count < 1) {\n    return segments\n  }\n\n  for (let i = 1; i <= count; i++) {\n    segments.push({\n      type: buffer.readUInt8(buffer.position)})\n\n    buffer.position++\n  }\n\n  return segments\n}\n\nconst parseGeography = buffer => {\n  // s2.1.1 + s.2.1.2\n\n  const srid = buffer.readInt32LE(0)\n  if (srid === -1) {\n    return null\n  }\n\n  const value = {\n    srid,\n    version: buffer.readUInt8(4)\n  }\n\n  const flags = buffer.readUInt8(5)\n  buffer.position = 6\n\n  // console.log(\"srid\", srid)\n  // console.log(\"version\", version)\n\n  const properties = {\n    Z: (flags & (1 << 0)) > 0,\n    M: (flags & (1 << 1)) > 0,\n    V: (flags & (1 << 2)) > 0,\n    P: (flags & (1 << 3)) > 0,\n    L: (flags & (1 << 4)) > 0\n  }\n\n  if (value.version === 2) {\n    properties.H = (flags & (1 << 3)) > 0\n  }\n\n  // console.log(\"properties\", properties);\n\n  let numberOfPoints\n  if (properties.P) {\n    numberOfPoints = 1\n  } else if (properties.L) {\n    numberOfPoints = 2\n  } else {\n    numberOfPoints = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfPoints\", numberOfPoints)\n\n  value.points = parsePoints(buffer, numberOfPoints)\n\n  if (properties.Z) {\n    parseZ(buffer, value.points)\n  }\n\n  if (properties.M) {\n    parseM(buffer, value.points)\n  }\n\n  // console.log(\"points\", points)\n\n  let numberOfFigures\n  if (properties.P) {\n    numberOfFigures = 1\n  } else if (properties.L) {\n    numberOfFigures = 1\n  } else {\n    numberOfFigures = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfFigures\", numberOfFigures)\n\n  value.figures = parseFigures(buffer, numberOfFigures, properties)\n\n  // console.log(\"figures\", figures)\n\n  let numberOfShapes\n  if (properties.P) {\n    numberOfShapes = 1\n  } else if (properties.L) {\n    numberOfShapes = 1\n  } else {\n    numberOfShapes = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n  }\n\n  // console.log(\"numberOfShapes\", numberOfShapes)\n\n  value.shapes = parseShapes(buffer, numberOfShapes, properties)\n\n  // console.log( \"shapes\", shapes)\n\n  if (value.version === 2) {\n    const numberOfSegments = buffer.readUInt32LE(buffer.position)\n    buffer.position += 4\n\n    // console.log(\"numberOfSegments\", numberOfSegments)\n\n    value.segments = parseSegments(buffer, numberOfSegments)\n\n    // console.log(\"segments\", segments)\n  } else {\n    value.segments = []\n  }\n\n  return value\n}\n\nmodule.exports.PARSERS = {\n  geography (buffer) {\n    return parseGeography(buffer)\n  },\n\n  geometry (buffer) {\n    return parseGeography(buffer)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/cli.js":"'use strict'\n\nconst fs = require('fs')\nconst path = require('path')\nconst sql = require('./main')\n\nconst exit = process.exit\nconst write = text => process.stdout.write(text)\nBuffer.prototype.toJSON = () => {\n  return `0x${this.toString('hex')}`\n}\n\n// Resolve config path\n\nlet cfgPath = path.resolve(process.argv[2] || process.cwd())\nif (fs.lstatSync(cfgPath).isDirectory()) {\n  cfgPath = path.resolve(cfgPath, './.mssql.json')\n}\nif (!fs.existsSync(cfgPath)) {\n  console.error('Config file not found.')\n  exit(1)\n}\n\n// Config checks & parse\n\nlet config\ntry {\n  config = fs.readFileSync(cfgPath)\n} catch (err) {\n  console.error(`Failed to load config file. ${err.message}`)\n  exit(1)\n}\n\ntry {\n  config = JSON.parse(config)\n} catch (err) {\n  console.error(`Failed to parse config file. ${err.message}`)\n  exit(1)\n}\n\n// Read stdin\n\nconst buffer = []\n\nprocess.stdin.setEncoding('utf8')\nprocess.stdin.on('readable', () => buffer.push(process.stdin.read()))\n\nprocess.stdin.on('end', () => {\n  const statement = buffer.join('')\n  let rst = 0\n  let index = 0\n\n  if (!statement.length) {\n    console.error('Statement is empty.')\n    exit(1)\n  }\n\n  sql.connect(config, err => {\n    if (err) {\n      console.error(err.message)\n      exit(1)\n    }\n\n    write('[')\n\n    const request = new sql.Request()\n    request.stream = true\n    request.on('recordset', () => {\n      index = 0\n      if (rst++ > 0) {\n        write('],')\n      }\n\n      return write('[')\n    })\n\n    request.on('error', err => {\n      console.error(err.message)\n      sql.close()\n      return exit(1)\n    })\n\n    request.on('row', row => {\n      if (index++ > 0) {\n        write(',')\n      }\n\n      return write(JSON.stringify(row))\n    })\n\n    request.on('done', () => {\n      if (rst > 0) {\n        write(']')\n      }\n\n      write(']\\n')\n      sql.close()\n      return exit(0)\n    })\n\n    request.query(statement)\n  })\n})\n\nprocess.on('uncaughtException', err => {\n  if (err.code === 'EPIPE') {\n    console.error('Failed to pipe output stream.')\n  } else {\n    console.error(err.message)\n  }\n\n  exit(1)\n})\n","/home/travis/build/npmtest/node-npmtest-mssql/node_modules/mssql/lib/msnodesqlv8.js":"'use strict'\n\nconst msnodesql = require('msnodesqlv8')\nconst debug = require('debug')('mssql:msnodesql')\n\nconst base = require('./base')\nconst TYPES = require('./datatypes').TYPES\nconst declare = require('./datatypes').declare\nconst UDT = require('./udt').PARSERS\nconst DECLARATIONS = require('./datatypes').DECLARATIONS\nconst ISOLATION_LEVEL = require('./isolationlevel')\n\nconst EMPTY_BUFFER = new Buffer(0)\nconst JSON_COLUMN_ID = 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B'\nconst XML_COLUMN_ID = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'\n\nconst CONNECTION_STRING_PORT = 'Driver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};'\nconst CONNECTION_STRING_NAMED_INSTANCE = 'Driver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};'\n\nconst castParameter = function (value, type) {\n  if (value == null) {\n    if ((type === TYPES.Binary) || (type === TYPES.VarBinary) || (type === TYPES.Image)) {\n      // msnodesql has some problems with NULL values in those types, so we need to replace it with empty buffer\n      return EMPTY_BUFFER\n    }\n\n    return null\n  }\n\n  switch (type) {\n    case TYPES.VarChar:\n    case TYPES.NVarChar:\n    case TYPES.Char:\n    case TYPES.NChar:\n    case TYPES.Xml:\n    case TYPES.Text:\n    case TYPES.NText:\n      if ((typeof value !== 'string') && !(value instanceof String)) {\n        value = value.toString()\n      }\n      break\n\n    case TYPES.Int:\n    case TYPES.TinyInt:\n    case TYPES.BigInt:\n    case TYPES.SmallInt:\n      if ((typeof value !== 'number') && !(value instanceof Number)) {\n        value = parseInt(value)\n        if (isNaN(value)) { value = null }\n      }\n      break\n\n    case TYPES.Float:\n    case TYPES.Real:\n    case TYPES.Decimal:\n    case TYPES.Numeric:\n    case TYPES.SmallMoney:\n    case TYPES.Money:\n      if ((typeof value !== 'number') && !(value instanceof Number)) {\n        value = parseFloat(value)\n        if (isNaN(value)) { value = null }\n      }\n      break\n\n    case TYPES.Bit:\n      if ((typeof value !== 'boolean') && !(value instanceof Boolean)) {\n        value = Boolean(value)\n      }\n      break\n\n    case TYPES.DateTime:\n    case TYPES.SmallDateTime:\n    case TYPES.DateTimeOffset:\n    case TYPES.Date:\n      if (!(value instanceof Date)) {\n        value = new Date(value)\n      }\n      break\n\n    case TYPES.Binary:\n    case TYPES.VarBinary:\n    case TYPES.Image:\n      if (!(value instanceof Buffer)) {\n        value = new Buffer(value.toString())\n      }\n      break\n  }\n\n  return value\n}\n\nconst createColumns = function (metadata) {\n  let out = {}\n  for (let index = 0, length = metadata.length; index < length; index++) {\n    let column = metadata[index]\n    out[column.name] = {\n      index,\n      name: column.name,\n      length: column.size,\n      type: DECLARATIONS[column.sqlType]\n    }\n\n    if (column.udtType != null) {\n      out[column.name].udt = {\n        name: column.udtType\n      }\n\n      if (DECLARATIONS[column.udtType]) {\n        out[column.name].type = DECLARATIONS[column.udtType]\n      }\n    }\n  }\n\n  return out\n}\n\nconst isolationLevelDeclaration = function (type) {\n  switch (type) {\n    case ISOLATION_LEVEL.READ_UNCOMMITTED: return 'READ UNCOMMITTED'\n    case ISOLATION_LEVEL.READ_COMMITTED: return 'READ COMMITTED'\n    case ISOLATION_LEVEL.REPEATABLE_READ: return 'REPEATABLE READ'\n    case ISOLATION_LEVEL.SERIALIZABLE: return 'SERIALIZABLE'\n    case ISOLATION_LEVEL.SNAPSHOT: return 'SNAPSHOT'\n    default: throw new base.TransactionError('Invalid isolation level.')\n  }\n}\n\nconst valueCorrection = function (value, metadata) {\n  if ((metadata.sqlType === 'time') && (value != null)) {\n    value.setFullYear(1970)\n    return value\n  } else if ((metadata.sqlType === 'udt') && (value != null)) {\n    if (UDT[metadata.udtType]) {\n      return UDT[metadata.udtType](value)\n    } else {\n      return value\n    }\n  } else {\n    return value\n  }\n}\n\nclass ConnectionPool extends base.ConnectionPool {\n  _poolCreate () {\n    return new base.Promise((resolve, reject) => {\n      debug('pool: create')\n\n      let defaultConnectionString = CONNECTION_STRING_PORT\n\n      if (this.config.options.instanceName != null) {\n        defaultConnectionString = CONNECTION_STRING_NAMED_INSTANCE\n      }\n\n      const cfg = {\n        conn_str: this.config.connectionString || defaultConnectionString,\n        conn_timeout: (this.config.connectionTimeout || 15000) / 1000\n      }\n\n      cfg.conn_str = cfg.conn_str.replace(new RegExp('#{([^}]*)}', 'g'), (p) => {\n        let key = p.substr(2, p.length - 3)\n\n        switch (key) {\n          case 'instance':\n            return this.config.options.instanceName\n          case 'trusted':\n            return this.config.options.trustedConnection ? 'Yes' : 'No'\n          default:\n            return this.config[key] != null ? this.config[key] : ''\n        }\n      })\n\n      msnodesql.open(cfg, (err, tds) => {\n        if (err) {\n          err = new base.ConnectionError(err)\n          return reject(err)\n        }\n\n        debug('pool: create ok')\n\n        resolve(tds)\n      })\n    })\n  }\n\n  _poolValidate (tds) {\n    return new base.Promise((resolve, reject) => {\n      resolve(!tds.hasError)\n    })\n  }\n\n  _poolDestroy (tds) {\n    return new base.Promise((resolve, reject) => {\n      debug('pool: destroy')\n\n      tds.close()\n      resolve()\n    })\n  }\n}\n\nclass Transaction extends base.Transaction {\n  _begin (isolationLevel, callback) {\n    super._begin(isolationLevel, err => {\n      if (err) return callback(err)\n\n      debug('tran: begin')\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        this._acquiredConnection = connection\n\n        const req = new Request(this)\n        req.stream = false\n        req.query(`set transaction isolation level ${isolationLevelDeclaration(this.isolationLevel)};begin tran;`, err => {\n          if (err) {\n            this.parent.release(this._acquiredConnection)\n            this._acquiredConnection = null\n\n            return callback(err)\n          }\n\n          debug('tran: begin ok')\n\n          callback(null)\n        })\n      })\n    })\n  }\n\n  _commit (callback) {\n    super._commit(err => {\n      if (err) return callback(err)\n\n      debug('tran: commit')\n\n      const req = new Request(this)\n      req.stream = false\n      req.query(`commit tran`, err => {\n        if (err) err = new base.TransactionError(err)\n\n        this.parent.release(this._acquiredConnection)\n        this._acquiredConnection = null\n\n        if (!err) debug('tran: commit ok')\n\n        callback(null)\n      })\n    })\n  }\n\n  _rollback (callback) {\n    super._commit(err => {\n      if (err) return callback(err)\n\n      debug('tran: rollback')\n\n      const req = new Request(this)\n      req.stream = false\n      req.query(`rollback tran`, err => {\n        if (err) err = new base.TransactionError(err)\n\n        this.parent.release(this._acquiredConnection)\n        this._acquiredConnection = null\n\n        if (!err) debug('tran: rollback ok')\n\n        callback(null)\n      })\n    })\n  }\n}\n\nclass Request extends base.Request {\n  _batch (batch, callback) {\n    this._isBatch = true\n    this._query(batch, callback)\n  }\n\n  _bulk (table, callback) {\n    super._bulk(table, err => {\n      if (err) return callback(err)\n\n      table._makeBulk()\n\n      if (!table.name) {\n        setImmediate(callback, new base.RequestError('Table name must be specified for bulk insert.', 'ENAME'))\n      }\n\n      if (table.name.charAt(0) === '@') {\n        setImmediate(callback, new base.RequestError(\"You can't use table variables for bulk insert.\", 'ENAME'))\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        if (!err) {\n          const done = (err, rowCount) => {\n            if (err) {\n              if ((typeof err.sqlstate === 'string') && (err.sqlstate.toLowerCase() === '08s01')) {\n                connection.hasError = true\n              }\n\n              err = new base.RequestError(err)\n              err.code = 'EREQUEST'\n            }\n\n            this.parent.release(connection)\n\n            if (err) {\n              callback(err)\n            } else {\n              callback(null, table.rows.length)\n            }\n          }\n\n          const go = () => {\n            let tm = connection.tableMgr()\n            return tm.bind(table.path.replace(/\\[|\\]/g, ''), mgr => {\n              if (mgr.columns.length === 0) {\n                return done(new base.RequestError('Table was not found on the server.', 'ENAME'))\n              }\n\n              let rows = []\n              for (let row of Array.from(table.rows)) {\n                let item = {}\n                for (let index = 0; index < table.columns.length; index++) {\n                  let col = table.columns[index]\n                  item[col.name] = row[index]\n                }\n\n                rows.push(item)\n              }\n\n              mgr.insertRows(rows, done)\n            })\n          }\n\n          if (table.create) {\n            let objectid\n            if (table.temporary) {\n              objectid = `tempdb..[${table.name}]`\n            } else {\n              objectid = table.path\n            }\n\n            return connection.queryRaw(`if object_id('${objectid.replace(/'/g, '\\'\\'')}') is null ${table.declare()}`, function (err) {\n              if (err) { return done(err) }\n              go()\n            })\n          } else {\n            go()\n          }\n        }\n      })\n    })\n  }\n\n  _query (command, callback) {\n    super._query(command, err => {\n      if (err) return callback(err)\n\n      debug('req: query')\n\n      if (command.length === 0) {\n        return callback(null, [])\n      }\n\n      let row = null\n      let columns = null\n      let recordset = null\n      const recordsets = []\n      const output = {}\n      const rowsAffected = []\n      let handleOutput = false\n      let isChunkedRecordset = false\n      let chunksBuffer = null\n\n      // nested = function is called by this.execute\n\n      if (!this._nested) {\n        const input = []\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          input.push(`@${param.name} ${declare(param.type, param)}`)\n        }\n\n        const sets = []\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          if (param.io === 1) {\n            sets.push(`set @${param.name}=?`)\n          }\n        }\n\n        const output = []\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          if (param.io === 2) {\n            output.push(`@${param.name} as '${param.name}'`)\n          }\n        }\n\n        if (input.length) command = `declare ${input.join(',')};${sets.join(';')};${command};`\n        if (output.length) {\n          command += `select ${output.join(',')};`\n          handleOutput = true\n        }\n      }\n\n      this.parent.acquire(this, (err, connection) => {\n        if (err) return callback(err)\n\n        debug('req:connection acquired')\n\n        const params = []\n        for (let name in this.parameters) {\n          let param = this.parameters[name]\n          if (param.io === 1) {\n            params.push(castParameter(param.value, param.type))\n          }\n        }\n\n        const req = connection.queryRaw(command, params)\n        req.on('meta', metadata => {\n          if (row) {\n            if (isChunkedRecordset) {\n              if ((columns[0].name === JSON_COLUMN_ID) && (this.connection.config.parseJSON === true)) {\n                try {\n                  row = JSON.parse(chunksBuffer.join(''))\n                  if (!this.stream) { recordsets[recordsets.length - 1][0] = row }\n                } catch (ex) {\n                  row = null\n                  const ex2 = new base.RequestError(`Failed to parse incoming JSON. ${ex.message}`, 'EJSON')\n\n                  if (this.stream) {\n                    this.emit('error', ex2)\n                  } else {\n                    console.error(ex2)\n                  }\n                }\n              } else {\n                row[columns[0].name] = chunksBuffer.join('')\n              }\n\n              chunksBuffer = null\n            }\n\n            if (row.___return___ == null) {\n              // row with ___return___ col is the last row\n              if (this.stream) this.emit('row', row)\n            }\n          }\n\n          row = null\n          columns = metadata\n          recordset = []\n\n          Object.defineProperty(recordset, 'columns', {\n            enumerable: false,\n            configurable: true,\n            value: createColumns(metadata)\n          })\n\n          isChunkedRecordset = false\n          if ((metadata.length === 1) && (metadata[0].name === JSON_COLUMN_ID || metadata[0].name === XML_COLUMN_ID)) {\n            isChunkedRecordset = true\n            chunksBuffer = []\n          }\n\n          if (this.stream) {\n            if (recordset.columns.___return___ == null) {\n              this.emit('recordset', recordset.columns)\n            }\n          } else {\n            recordsets.push(recordset)\n          }\n        })\n\n        req.on('row', rownumber => {\n          if (row) {\n            if (isChunkedRecordset) return\n\n            if (row.___return___ == null) {\n              // row with ___return___ col is the last row\n              if (this.stream) this.emit('row', row)\n            }\n          }\n\n          row = {}\n\n          if (!this.stream) recordset.push(row)\n        })\n\n        req.on('column', (idx, data, more) => {\n          if (isChunkedRecordset) {\n            chunksBuffer.push(data)\n          } else {\n            data = valueCorrection(data, columns[idx])\n\n            let exi = row[columns[idx].name]\n            if (exi != null) {\n              if (exi instanceof Array) {\n                exi.push(data)\n              } else {\n                row[columns[idx].name] = [exi, data]\n              }\n            } else {\n              row[columns[idx].name] = data\n            }\n          }\n        })\n\n        req.on('rowcount', count => {\n          rowsAffected.push(count)\n        })\n\n        req.once('error', err => {\n          if ((typeof err.sqlstate === 'string') && (err.sqlstate.toLowerCase() === '08s01')) {\n            connection.hasError = true\n          }\n\n          err = new base.RequestError(err)\n          err.code = 'EREQUEST'\n\n          this.parent.release(connection)\n\n          debug('req: query failed', err)\n          callback(err)\n        })\n\n        req.once('done', () => {\n          if (!this._nested) {\n            if (row) {\n              if (isChunkedRecordset) {\n                if ((columns[0].name === JSON_COLUMN_ID) && (this.connection.config.parseJSON === true)) {\n                  try {\n                    row = JSON.parse(chunksBuffer.join(''))\n                    if (!this.stream) { recordsets[recordsets.length - 1][0] = row }\n                  } catch (ex) {\n                    row = null\n                    const ex2 = new base.RequestError(`Failed to parse incoming JSON. ${ex.message}`, 'EJSON')\n\n                    if (this.stream) {\n                      this.emit('error', ex2)\n                    } else {\n                      console.error(ex2)\n                    }\n                  }\n                } else {\n                  row[columns[0].name] = chunksBuffer.join('')\n                }\n\n                chunksBuffer = null\n              }\n\n              if (row['___return___'] == null) {\n                // row with ___return___ col is the last row\n                if (this.stream) { this.emit('row', row) }\n              }\n            }\n\n            // do we have output parameters to handle?\n            if (handleOutput && recordsets.length) {\n              let last = recordsets.pop()[0]\n\n              for (let name in this.parameters) {\n                let param = this.parameters[name]\n                if (param.io === 2) {\n                  output[param.name] = last[param.name]\n                }\n              }\n            }\n          }\n\n          this.parent.release(connection)\n\n          debug('req: query ok')\n\n          if (this.stream) {\n            callback(null, this._nested ? row : null, output, rowsAffected)\n          } else {\n            callback(null, recordsets, output, rowsAffected)\n          }\n        })\n      })\n    })\n  }\n\n  _execute (procedure, callback) {\n    super._execute(procedure, err => {\n      if (err) return callback(err)\n\n      const params = []\n      for (let name in this.parameters) {\n        let param = this.parameters[name]\n        if (param.io === 2) {\n          params.push(`@${param.name} ${declare(param.type, param)}`)\n        }\n      }\n\n      let cmd = `declare ${['@___return___ int'].concat(params).join(', ')};`\n      cmd += `exec @___return___ = ${procedure} `\n\n      const spp = []\n      for (let name in this.parameters) {\n        let param = this.parameters[name]\n\n        if (param.io === 2) {\n          // output parameter\n          spp.push(`@${param.name}=@${param.name} output`)\n        } else {\n          // input parameter\n          spp.push(`@${param.name}=?`)\n        }\n      }\n\n      const params2 = []\n      for (let name in this.parameters) {\n        let param = this.parameters[name]\n        if (param.io === 2) {\n          params2.push(`@${param.name} as '${param.name}'`)\n        }\n      }\n\n      cmd += `${spp.join(', ')};`\n      cmd += `select ${['@___return___ as \\'___return___\\''].concat(params2).join(', ')};`\n\n      this._nested = true\n\n      this._query(cmd, (err, recordsets, output, rowsAffected) => {\n        this._nested = false\n\n        if (err) return callback(err)\n\n        let last, returnValue\n        if (this.stream) {\n          last = recordsets\n        } else {\n          last = recordsets.pop()\n          if (last) last = last[0]\n        }\n\n        if (last && (last.___return___ != null)) {\n          returnValue = last.___return___\n\n          for (let name in this.parameters) {\n            let param = this.parameters[name]\n            if (param.io === 2) {\n              output[param.name] = last[param.name]\n            }\n          }\n        }\n\n        if (this.stream) {\n          callback(null, null, output, returnValue, rowsAffected)\n        } else {\n          callback(null, recordsets, output, returnValue, rowsAffected)\n        }\n      })\n    })\n  }\n\n  /*\n  Cancel currently executed request.\n  */\n\n  cancel () {\n    return false // Request canceling is not implemented by msnodesql driver.\n  }\n}\n\nmodule.exports = Object.assign({\n  ConnectionPool,\n  Transaction,\n  Request,\n  PreparedStatement: base.PreparedStatement\n}, base.exports)\n\nObject.defineProperty(module.exports, 'Promise', {\n  enumerable: true,\n  get: () => {\n    return base.Promise\n  },\n  set: (value) => {\n    base.Promise = value\n  }\n})\n\nbase.driver.name = 'msnodesqlv8'\nbase.driver.ConnectionPool = ConnectionPool\nbase.driver.Transaction = Transaction\nbase.driver.Request = Request\n"}